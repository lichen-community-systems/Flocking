/*! Flocking 1.0.0, Copyright 2018 Colin Clark | flockingjs.org */


"use strict";

!function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.ArrayMath) {
        var t = {
            add: function(e, t, n) {
                var o;
                if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; 0 <= o; --o) e[o] = t[o] + n[o]; else for (o = Math.min(e.length, n.length) - 1; 0 <= o; --o) e[o] = t + n[o];
            },
            sub: function(e, t, n) {
                var o;
                if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; 0 <= o; --o) e[o] = t[o] - n[o]; else for (o = Math.min(e.length, n.length) - 1; 0 <= o; --o) e[o] = t - n[o];
            },
            mul: function(e, t, n) {
                var o;
                if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; 0 <= o; --o) e[o] = t[o] * n[o]; else for (o = Math.min(e.length, n.length) - 1; 0 <= o; --o) e[o] = t * n[o];
            },
            mulCplx: function(e, t, n, o, r, a) {
                var i, l, u, s, f;
                if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, o.length, r.length, a.length) - 1; 0 <= i; --i) l = n[i], 
                u = o[i], s = r[i], f = a[i], e[i] = l * s - u * f, t[i] = l * f + u * s; else for (i = Math.min(e.length, t.length, r.length, a.length) - 1; 0 <= i; --i) s = r[i], 
                f = a[i], e[i] = n * s - o * f, t[i] = n * f + o * s;
            },
            div: function(e, t, n) {
                var o;
                if (t instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; 0 <= o; --o) e[o] = t[o] / n[o]; else for (o = Math.min(e.length, n.length) - 1; 0 <= o; --o) e[o] = t / n[o];
            },
            divCplx: function(e, t, n, o, r, a) {
                var i, l, u, s, f, c;
                if (n instanceof Float32Array) for (i = Math.min(e.length, t.length, n.length, o.length, r.length, a.length) - 1; 0 <= i; --i) l = n[i], 
                u = o[i], c = 1 / ((s = r[i]) * s + (f = a[i]) * f), e[i] = (l * s + u * f) * c, 
                t[i] = (u * s - l * f) * c; else for (i = Math.min(e.length, t.length, r.length, a.length) - 1; 0 <= i; --i) c = 1 / ((s = r[i]) * s + (f = a[i]) * f), 
                e[i] = (n * s + o * f) * c, t[i] = (o * s - n * f) * c;
            },
            madd: function(e, t, n, o) {
                var r;
                if (t instanceof Float32Array) for (r = Math.min(e.length, t.length, n.length, o.length) - 1; 0 <= r; --r) e[r] = t[r] * n[r] + o[r]; else for (r = Math.min(e.length, n.length, o.length) - 1; 0 <= r; --r) e[r] = t * n[r] + o[r];
            },
            abs: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.abs(t[n]);
            },
            absCplx: function(e, t, n) {
                for (var o = Math.min(e.length, t.length, n.length) - 1; 0 <= o; --o) e[o] = Math.sqrt(t[o] * t[o] + n[o] * n[o]);
            },
            acos: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.acos(t[n]);
            },
            asin: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.asin(t[n]);
            },
            atan: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.atan(t[n]);
            },
            atan2: function(e, t, n) {
                for (var o = Math.min(e.length, n.length, t.length) - 1; 0 <= o; --o) e[o] = Math.atan2(t[o], n[o]);
            },
            ceil: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.ceil(t[n]);
            },
            cos: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.cos(t[n]);
            },
            exp: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.exp(t[n]);
            },
            floor: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.floor(t[n]);
            },
            log: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.log(t[n]);
            },
            max: function(e) {
                for (var t = -1 / 0, n = e.length - 1; 0 <= n; --n) {
                    var o = e[n];
                    t < o && (t = o);
                }
                return t;
            },
            min: function(e) {
                for (var t = 1 / 0, n = e.length - 1; 0 <= n; --n) {
                    var o = e[n];
                    o < t && (t = o);
                }
                return t;
            },
            pow: function(e, t, n) {
                var o;
                if (n instanceof Float32Array) for (o = Math.min(e.length, t.length, n.length) - 1; 0 <= o; --o) e[o] = Math.pow(t[o], n[o]); else for (o = Math.min(e.length, t.length) - 1; 0 <= o; --o) e[o] = Math.pow(t[o], n);
            },
            random: function(e, t, n) {
                t || (t = 0), isNaN(parseFloat(n)) && (n = 1);
                for (var o = n - t, r = e.length - 1; 0 <= r; --r) e[r] = Math.random() * o + t;
            },
            round: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.round(t[n]);
            },
            sin: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.sin(t[n]);
            },
            sqrt: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.sqrt(t[n]);
            },
            tan: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = Math.tan(t[n]);
            },
            clamp: function(e, t, n, o) {
                for (var r = Math.min(e.length, t.length) - 1; 0 <= r; --r) {
                    var a = t[r];
                    e[r] = a < n ? n : o < a ? o : a;
                }
            },
            fract: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) {
                    var o = t[n];
                    e[n] = o - Math.floor(o);
                }
            },
            fill: function(e, t) {
                for (var n = e.length - 1; 0 <= n; --n) e[n] = t;
            },
            ramp: function(e, t, n) {
                var o = e.length - 1;
                if (0 <= o && (e[0] = t), 0 < o) for (var r = (n - t) / o, a = 1; a <= o; ++a) e[a] = t + r * a;
            },
            sign: function(e, t) {
                for (var n = Math.min(e.length, t.length) - 1; 0 <= n; --n) e[n] = t[n] < 0 ? -1 : 1;
            },
            sum: function(e) {
                for (var t = 0, n = e.length - 1; 0 <= n; --n) t += e[n];
                return t;
            },
            sampleLinear: function(e, t, n) {
                for (var o = t.length - 1, r = Math.min(e.length, n.length) - 1; 0 <= r; --r) {
                    var a = n[r];
                    a = a < 0 ? 0 : o < a ? o : a;
                    var i = Math.floor(a), l = a - i, u = t[i], s = t[i < o ? i + 1 : o];
                    e[r] = u + l * (s - u);
                }
            },
            sampleLinearRepeat: function(e, t, n) {
                for (var o = t.length, r = o - 1, a = Math.min(e.length, n.length) - 1; 0 <= a; --a) {
                    var i = n[a];
                    i -= Math.floor(i / o) * o;
                    var l = Math.floor(i), u = i - l, s = t[l], f = t[l < r ? l + 1 : 0];
                    e[a] = s + u * (f - s);
                }
            },
            sampleCubic: function(e, t, n) {
                for (var o = t.length - 1, r = Math.min(e.length, n.length) - 1; 0 <= r; --r) {
                    var a = n[r];
                    a = a < 0 ? 0 : o < a ? o : a;
                    var i = Math.floor(a), l = a - i, u = l * l, s = u * l, f = -2 * s + 3 * u, c = 1 - f, d = s - u, m = d - u + l, h = t[0 < i ? i - 1 : 0], p = t[i], k = t[i < o ? i + 1 : o], g = t[i < o - 1 ? i + 2 : o];
                    e[r] = c * p + f * k + .5 * (m * (k - h) + d * (g - p));
                }
            },
            sampleCubicRepeat: function(e, t, n) {
                for (var o = t.length, r = o - 1, a = Math.min(e.length, n.length) - 1; 0 <= a; --a) {
                    var i = n[a];
                    i -= Math.floor(i / o) * o;
                    var l = Math.floor(i), u = i - l, s = u * u, f = s * u, c = -2 * f + 3 * s, d = 1 - c, m = f - s, h = m - s + u, p = t[0 < l ? l - 1 : r], k = t[l], g = t[l < r ? l + 1 : 0], v = t[l < r - 1 ? l + 2 : l + 2 - Math.floor((l + 2) / o) * o];
                    e[a] = d * k + c * g + .5 * (h * (g - p) + m * (v - k));
                }
            },
            pack: function(e, t, n, o, r, a, i) {
                var l = Math.floor(Math.max(0, e.length - t) / n), u = Math.min(l, o.length);
                if (r) {
                    u = Math.min(u, r.length);
                    if (a) {
                        u = Math.min(u, a.length);
                        if (i) {
                            u = Math.min(u, i.length);
                            for (var s = 0; s < u; ++s) e[t] = o[s], e[t + 1] = r[s], e[t + 2] = a[s], e[t + 3] = i[s], 
                            t += n;
                        } else for (s = 0; s < u; ++s) e[t] = o[s], e[t + 1] = r[s], e[t + 2] = a[s], t += n;
                    } else for (s = 0; s < u; ++s) e[t] = o[s], e[t + 1] = r[s], t += n;
                } else for (s = 0; s < u; ++s) e[t] = o[s], t += n;
            },
            unpack: function(e, t, n, o, r, a, i) {
                var l = Math.floor(Math.max(0, e.length - t) / n), u = Math.min(l, o.length);
                if (r) {
                    u = Math.min(u, r.length);
                    if (a) {
                        u = Math.min(u, a.length);
                        if (i) {
                            u = Math.min(u, i.length);
                            for (var s = 0; s < u; ++s) o[s] = e[t], r[s] = e[t + 1], a[s] = e[t + 2], i[s] = e[t + 3], 
                            t += n;
                        } else for (s = 0; s < u; ++s) o[s] = e[t], r[s] = e[t + 1], a[s] = e[t + 2], t += n;
                    } else for (s = 0; s < u; ++s) o[s] = e[t], r[s] = e[t + 1], t += n;
                } else for (s = 0; s < u; ++s) o[s] = e[t], t += n;
            }
        };
        e.ArrayMath = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.Filter) {
        var t = function(e, t) {
            !isNaN(parseFloat(e)) && isFinite(e) || (e = 1), t || (t = 0), this._b = new Float32Array(e), 
            this._b[0] = 1, this._a = new Float32Array(t), this._bHist = new Float32Array(e), 
            this._aHist = new Float32Array(t);
        };
        t.prototype.filter = function(e, t) {
            var n, o = this._a, r = o.length, a = this._b, i = a.length, l = this._aHist, u = this._bHist, s = t.length, f = e.length, c = i - 1, d = r;
            for (n = 0; (c || d) && n < s; ++n) {
                var m;
                m = i - c, c && c--;
                var h = a[0] * t[n];
                for (C = 1; C < m; ++C) h += a[C] * t[n - C];
                for (;C < i; ++C) h += a[C] * u[C - m];
                for (m = r - d, d && d--, C = 0; C < m; ++C) h -= o[C] * e[n - 1 - C];
                for (;C < r; ++C) h -= o[C] * l[C - m];
                e[n] = h;
            }
            if (3 == i && 2 == r) for (var p, k, g = a[0], v = a[1], y = a[2], b = o[0], w = o[1], A = t[n - 1], N = t[n - 2], M = e[n - 1], S = e[n - 2]; n < s; ++n) p = N, 
            N = A, k = S, M = g * (A = t[n]) + v * N + y * p - b * (S = M) - w * k, e[n] = M; else for (;n < s; ++n) {
                var C;
                h = a[0] * t[n];
                for (C = 1; C < i; ++C) h += a[C] * t[n - C];
                for (C = 0; C < r; ++C) h -= o[C] * e[n - 1 - C];
                e[n] = h;
            }
            var I = Math.min(i - 1, s);
            for (n = i - 2; I <= n; --n) u[n] = u[n - I];
            for (n = 0; n < I; ++n) u[n] = t[s - 1 - n];
            for (I = Math.min(r, f), n = r - 1; I <= n; --n) l[n] = l[n - I];
            for (n = 0; n < I; ++n) l[n] = e[s - 1 - n];
        }, t.prototype.clearHistory = function() {
            for (var e = this._bHist.length - 1; 0 <= e; --e) this._bHist[e] = 0;
            for (e = this._aHist.length - 1; 0 <= e; --e) this._aHist[e] = 0;
        }, t.prototype.setB = function(e) {
            for (var t = Math.min(this._b.length, e.length), n = 0; n < t; ++n) this._b[n] = e[n];
        }, t.prototype.setA = function(e) {
            for (var t = Math.min(this._a.length, e.length), n = 0; n < t; ++n) this._a[n] = e[n];
        }, e.Filter = t;
    }
}(), function() {
    var e = "undefined" != typeof window ? window : "undefined" != typeof self ? self : "undefined" != typeof module && module.exports ? module.exports : global;
    if (!e.FFT) {
        var y = function(e, t, n, o, r, a, i, l, u, s, f, c, d, m) {
            var h = u[s++], p = u[s++], k = n, g = n + h * p, v = i * l;
            if (1 == p) for (;e[n] = o[a], t[n] = r[a], a += v, ++n != g; ) ; else for (;y(e, t, n, o, r, a, i * h, l, u, s, f, c, d, m), 
            a += v, (n += p) != g; ) ;
            switch (n = k, h) {
              case 2:
                !function(e, t, n, o, r, a, i) {
                    for (var l, u, s, f, c, d, m, h, p = 0, k = n, g = n + i, v = .7071067811865475, y = k + i; k < y; ) s = e[k] * v, 
                    f = t[k] * v, c = e[g] * v, d = t[g] * v, l = c * (m = r[p]) - d * (h = a[p]), u = c * h + d * m, 
                    e[g] = s - l, t[g] = f - u, e[k] = s + l, t[k] = f + u, p += o, ++k, ++g;
                }(e, t, n, i, f, c, p);
                break;

              case 3:
                !function(e, t, n, o, r, a, i) {
                    for (var l, u, s, f, c, d, m, h, p, k, g, v, y, b, w, A, N = 0, M = 0, S = 2 * o, C = n, I = n + i, x = n + 2 * i, D = a[o * i], L = .5773502691896258, F = C + i; C < F; ) p = e[C] * L, 
                    k = t[C] * L, g = e[I] * L, v = t[I] * L, y = e[x] * L, b = t[x] * L, w = r[N], 
                    f = g * (A = a[N]) + v * w, l = (s = g * w - v * A) - (c = y * (w = r[M]) - b * (A = a[M])), 
                    u = f - (d = y * A + b * w), g = p - .5 * (m = s + c), v = k - .5 * (h = f + d), 
                    l *= D, u *= D, e[C] = p + m, t[C] = k + h, e[x] = g + u, t[x] = v - l, e[I] = g - u, 
                    t[I] = v + l, N += o, M += S, ++C, ++I, ++x;
                }(e, t, n, i, f, c, p);
                break;

              case 4:
                !function(e, t, n, o, r, a, i, l) {
                    for (var u, s, f, c, d, m, h, p, k, g, v, y, b, w, A, N, M, S, C, I, x, D, L = 0, F = 0, P = 0, O = 2 * o, B = 3 * o, R = n, T = n + i, E = n + 2 * i, V = n + 3 * i, U = R + i; R < U; ) b = .5 * e[R], 
                    w = .5 * t[R], A = .5 * e[T], N = .5 * t[T], M = .5 * e[E], S = .5 * t[E], C = .5 * e[V], 
                    I = .5 * t[V], u = A * (x = r[L]) - N * (D = a[L]), s = A * D + N * x, v = b - (f = M * (x = r[F]) - S * (D = a[F])), 
                    y = w - (c = M * D + S * x), b += f, w += c, h = u + (d = C * (x = r[P]) - I * (D = a[P])), 
                    p = s + (m = C * D + I * x), k = u - d, g = s - m, e[E] = b - h, t[E] = w - p, e[R] = b + h, 
                    t[R] = w + p, l ? (e[T] = v - g, t[T] = y + k, e[V] = v + g, t[V] = y - k) : (e[T] = v + g, 
                    t[T] = y - k, e[V] = v - g, t[V] = y + k), L += o, F += O, P += B, ++R, ++T, ++E, 
                    ++V;
                }(e, t, n, i, f, c, p, m);
                break;

              case 5:
                !function(e, t, n, o, r, a, i) {
                    for (var l, u, s, f, c, d, m, h, p, k, g, v, y, b, w, A, N, M, S, C, I, x, D, L, F, P, O, B, R, T, E, V, U, q, G, _, W, z, j = 0, H = 0, K = 0, J = 0, Q = 2 * o, X = 3 * o, Y = 4 * o, $ = n, Z = n + i, ee = n + 2 * i, te = n + 3 * i, ne = n + 4 * i, oe = r[o * i], re = a[o * i], ae = r[2 * o * i], ie = a[2 * o * i], le = .4472135954999579, ue = $ + i; $ < ue; ) O = e[$] * le, 
                    B = t[$] * le, R = e[Z] * le, T = t[Z] * le, E = e[ee] * le, V = t[ee] * le, U = e[te] * le, 
                    q = t[te] * le, G = e[ne] * le, _ = t[ne] * le, l = O, u = B, s = R * (W = r[j]) - T * (z = a[j]), 
                    f = R * z + T * W, c = E * (W = r[H]) - V * (z = a[H]), d = E * z + V * W, m = U * (W = r[K]) - q * (z = a[K]), 
                    h = U * z + q * W, w = s + (p = G * (W = r[J]) - _ * (z = a[J])), A = f + (k = G * z + _ * W), 
                    I = s - p, x = f - k, N = c + m, M = d + h, S = c - m, C = d - h, e[$] = O + w + N, 
                    t[$] = B + A + M, g = l + w * oe + N * ae, v = u + A * oe + M * ae, y = x * re + C * ie, 
                    b = -I * re - S * ie, e[Z] = g - y, t[Z] = v - b, e[ne] = g + y, t[ne] = v + b, 
                    D = l + w * ae + N * oe, L = u + A * ae + M * oe, F = -x * ie + C * re, P = I * ie - S * re, 
                    e[ee] = D + F, t[ee] = L + P, e[te] = D - F, t[te] = L - P, j += o, H += Q, K += X, 
                    J += Y, ++$, ++Z, ++ee, ++te, ++ne;
                }(e, t, n, i, f, c, p);
                break;

              default:
                !function(e, t, n, o, r, a, i, l, u) {
                    var s, f, c, d, m, h, p, k, g, v, y = new Float32Array(l), b = new Float32Array(l), w = Math.sqrt(1 / l);
                    for (s = 0; s < i; ++s) {
                        for (d = n + s, f = 0; f < l; ++f) y[f] = e[d] * w, b[f] = t[d] * w, d += i;
                        d = n + s;
                        var A = o * s;
                        for (f = 0; f < l; ++f) {
                            m = y[0], h = b[0];
                            var N = 0;
                            for (c = 1; c < l; ++c) u <= (N += A) && (N -= u), p = y[c], k = b[c], m += p * (g = r[N]) - k * (v = a[N]), 
                            h += p * v + k * g;
                            e[d] = m, t[d] = h, d += i, A += o;
                        }
                    }
                }(e, t, n, i, f, c, p, h, d);
            }
        }, t = function(e) {
            e || (e = 256), Object.defineProperty(this, "size", {
                configurable: !1,
                writable: !1,
                value: e
            }), this._twiddlesFwdRe = new Float32Array(e), this._twiddlesFwdIm = new Float32Array(e), 
            this._twiddlesInvRe = this._twiddlesFwdRe, this._twiddlesInvIm = new Float32Array(e);
            for (var t = 0; t < e; ++t) {
                var n = -2 * Math.PI * t / e, o = Math.cos(n), r = Math.sin(n);
                this._twiddlesFwdRe[t] = o, this._twiddlesFwdIm[t] = r, this._twiddlesInvIm[t] = -r;
            }
            this._factors = new Int32Array(64), function(e, t) {
                var n = 4, o = Math.floor(Math.sqrt(e)), r = 0;
                do {
                    for (;e % n; ) {
                        switch (n) {
                          case 4:
                            n = 2;
                            break;

                          case 2:
                            n = 3;
                            break;

                          default:
                            n += 2;
                        }
                        o < n && (n = e);
                    }
                    e = Math.floor(e / n), t[r++] = n, t[r++] = e;
                } while (1 < e);
            }(e, this._factors);
        };
        t.prototype.forwardCplx = function(e, t, n, o) {
            var r = this._twiddlesFwdRe, a = this._twiddlesFwdIm;
            y(e, t, 0, n, o, 0, 1, 1, this._factors, 0, r, a, this.size, !1);
        }, t.prototype.forward = function(e, t, n) {
            this.forwardCplx(e, t, n, new Float32Array(this.size));
        }, t.prototype.inverseCplx = function(e, t, n, o) {
            var r = this._twiddlesInvRe, a = this._twiddlesInvIm;
            y(e, t, 0, n, o, 0, 1, 1, this._factors, 0, r, a, this.size, !0);
        }, t.prototype.inverse = function(e, t, n) {
            this.inverseCplx(e, new Float32Array(this.size), t, n);
        }, e.FFT = t;
    }
}();

var Random = function(e) {
    if ("number" != typeof (e = void 0 === e ? new Date().getTime() : e) || Math.ceil(e) != Math.floor(e)) throw new TypeError("seed value must be an integer");
    this.N = 624, this.M = 397, this.MATRIX_A = 2567483615, this.UPPER_MASK = 2147483648, 
    this.LOWER_MASK = 2147483647, this.mt = new Array(this.N), this.mti = this.N + 1, 
    this.init_by_array([ e ], 1);
};

Random.prototype.init_genrand = function(e) {
    for (this.mt[0] = e >>> 0, this.mti = 1; this.mti < this.N; this.mti++) {
        e = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30;
        this.mt[this.mti] = (1812433253 * ((4294901760 & e) >>> 16) << 16) + 1812433253 * (65535 & e) + this.mti, 
        this.mt[this.mti] >>>= 0;
    }
}, Random.prototype.init_by_array = function(e, t) {
    var n, o, r;
    for (this.init_genrand(19650218), n = 1, o = 0, r = this.N > t ? this.N : t; r; r--) {
        var a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1664525 * ((4294901760 & a) >>> 16) << 16) + 1664525 * (65535 & a)) + e[o] + o, 
        this.mt[n] >>>= 0, o++, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1), 
        t <= o && (o = 0);
    }
    for (r = this.N - 1; r; r--) {
        a = this.mt[n - 1] ^ this.mt[n - 1] >>> 30;
        this.mt[n] = (this.mt[n] ^ (1566083941 * ((4294901760 & a) >>> 16) << 16) + 1566083941 * (65535 & a)) - n, 
        this.mt[n] >>>= 0, ++n >= this.N && (this.mt[0] = this.mt[this.N - 1], n = 1);
    }
    this.mt[0] = 2147483648;
}, Random.prototype.genrand_int32 = function() {
    var e, t = new Array(0, this.MATRIX_A);
    if (this.mti >= this.N) {
        var n;
        for (this.mti == this.N + 1 && this.init_genrand(5489), n = 0; n < this.N - this.M; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + this.M] ^ e >>> 1 ^ t[1 & e];
        for (;n < this.N - 1; n++) e = this.mt[n] & this.UPPER_MASK | this.mt[n + 1] & this.LOWER_MASK, 
        this.mt[n] = this.mt[n + (this.M - this.N)] ^ e >>> 1 ^ t[1 & e];
        e = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ e >>> 1 ^ t[1 & e], 
        this.mti = 0;
    }
    return e = this.mt[this.mti++], e ^= e >>> 11, e ^= e << 7 & 2636928640, e ^= e << 15 & 4022730752, 
    (e ^= e >>> 18) >>> 0;
}, Random.prototype.genrand_int31 = function() {
    return this.genrand_int32() >>> 1;
}, Random.prototype.genrand_real1 = function() {
    return this.genrand_int32() * (1 / 4294967295);
}, Random.prototype.random = function() {
    return this.pythonCompatibility && (this.skip && this.genrand_int32(), this.skip = !0), 
    this.genrand_int32() * (1 / 4294967296);
}, Random.prototype.genrand_real3 = function() {
    return (this.genrand_int32() + .5) * (1 / 4294967296);
}, Random.prototype.genrand_res53 = function() {
    return (67108864 * (this.genrand_int32() >>> 5) + (this.genrand_int32() >>> 6)) * (1 / 9007199254740992);
}, Random.prototype.LOG4 = Math.log(4), Random.prototype.SG_MAGICCONST = 1 + Math.log(4.5), 
Random.prototype.exponential = function(e) {
    if (1 != arguments.length) throw new SyntaxError("exponential() must  be called with 'lambda' parameter");
    var t = this.random();
    return -Math.log(t) / e;
}, Random.prototype.gamma = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("gamma() must be called with alpha and beta parameters");
    if (!(1 < e)) {
        if (1 == e) {
            for (var n = this.random(); n <= 1e-7; ) n = this.random();
            return -Math.log(n) * t;
        }
        for (;;) {
            n = this.random();
            var o = (Math.E + e) / Math.E, r = o * n;
            if (r <= 1) s = Math.pow(r, 1 / e); else s = -Math.log((o - r) / e);
            u = this.random();
            if (1 < r) {
                if (u <= Math.pow(s, e - 1)) break;
            } else if (u <= Math.exp(-s)) break;
        }
        return s * t;
    }
    for (var a = Math.sqrt(2 * e - 1), i = e - this.LOG4, l = e + a; ;) {
        var u;
        if (!((u = this.random()) < 1e-7 || .9999999 < n)) {
            var s, f = 1 - this.random(), c = Math.log(u / (1 - u)) / a, d = u * u * f, m = i + l * c - (s = e * Math.exp(c));
            if (0 <= m + this.SG_MAGICCONST - 4.5 * d || m >= Math.log(d)) return s * t;
        }
    }
}, Random.prototype.normal = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("normal() must be called with mu and sigma parameters");
    var n = this.lastNormal;
    if (this.lastNormal = NaN, !n) {
        var o = 2 * this.random() * Math.PI, r = Math.sqrt(-2 * Math.log(1 - this.random()));
        n = Math.cos(o) * r, this.lastNormal = Math.sin(o) * r;
    }
    return e + n * t;
}, Random.prototype.pareto = function(e) {
    if (1 != arguments.length) throw new SyntaxError("pareto() must be called with alpha parameter");
    var t = this.random();
    return 1 / Math.pow(1 - t, 1 / e);
}, Random.prototype.triangular = function(e, t, n) {
    if (3 != arguments.length) throw new SyntaxError("triangular() must be called with lower, upper and mode parameters");
    var o = (n - e) / (t - e), r = this.random();
    return r <= o ? e + Math.sqrt(r * (t - e) * (n - e)) : t - Math.sqrt((1 - r) * (t - e) * (t - n));
}, Random.prototype.uniform = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("uniform() must be called with lower and upper parameters");
    return e + this.random() * (t - e);
}, Random.prototype.weibull = function(e, t) {
    if (2 != arguments.length) throw new SyntaxError("weibull() must be called with alpha and beta parameters");
    var n = 1 - this.random();
    return e * Math.pow(-Math.log(n), 1 / t);
}, "undefined" == typeof window && "undefined" != typeof module && module.exports && (module.exports = Random);

var flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var a = fluid.registerNamespace("jQuery");
    if (flock.fluid = fluid, flock.init = function(e) {
        var t = e ? {
            components: {
                audioSystem: {
                    options: {
                        model: e
                    }
                }
            }
        } : void 0;
        return flock.enviro(t);
    }, flock.ALL_CHANNELS = 32, flock.OUT_UGEN_ID = "flocking-out", flock.PI = Math.PI, 
    flock.TWOPI = 2 * Math.PI, flock.HALFPI = Math.PI / 2, flock.LOG01 = Math.log(.1), 
    flock.LOG001 = Math.log(.001), flock.ROOT2 = Math.sqrt(2), flock.rates = {
        AUDIO: "audio",
        CONTROL: "control",
        SCHEDULED: "scheduled",
        DEMAND: "demand",
        CONSTANT: "constant"
    }, fluid.registerNamespace("flock.debug"), flock.debug.failHard = !0, flock.browser = function() {
        if ("undefined" == typeof navigator) return {};
        var e, t, n = navigator.userAgent.toLowerCase(), o = {};
        return (t = {
            browser: (e = /(chrome)[ \/]([\w.]+)/.exec(n) || /(webkit)[ \/]([\w.]+)/.exec(n) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(n) || /(msie) ([\w.]+)/.exec(n) || n.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(n) || [])[1] || "",
            version: e[2] || "0"
        }).browser && (o[t.browser] = !0, o.version = t.version), o.chrome ? o.webkit = !0 : o.webkit && (o.safari = !0), 
        o;
    }, fluid.registerNamespace("flock.platform"), flock.platform.isBrowser = "undefined" != typeof window, 
    flock.platform.hasRequire = "undefined" != typeof require, flock.platform.os = flock.platform.isBrowser ? window.navigator.platform : require("os").platform(), 
    flock.platform.isLinux = -1 < flock.platform.os.indexOf("Linux"), flock.platform.isAndroid = flock.platform.isLinux && -1 < flock.platform.os.indexOf("arm"), 
    flock.platform.isIOS = "iPhone" === flock.platform.os || "iPad" === flock.platform.os || "iPod" === flock.platform.os, 
    flock.platform.isMobile = flock.platform.isAndroid || flock.platform.isIOS, flock.platform.browser = flock.browser(), 
    flock.platform.isWebAudio = "undefined" != typeof AudioContext || "undefined" != typeof webkitAudioContext, 
    flock.platform.audioEngine = flock.platform.isBrowser ? "webAudio" : "nodejs", flock.platform.browser && void 0 !== flock.platform.browser.version) {
        var e = flock.platform.browser.version.indexOf(".");
        flock.platform.browser.majorVersionNumber = Number(e < 0 ? flock.platform.browser.version : flock.platform.browser.version.substring(0, e));
    }
    flock.shim = {
        URL: flock.platform.isBrowser ? window.URL || window.webkitURL || window.msURL : void 0
    }, flock.requireModule = function(e, t) {
        if (flock.platform.isBrowser) return window[t || e];
        if (flock.platform.hasRequire) {
            var n = flock.requireModule.paths[e] || e, o = require(n);
            return t ? o[t] : o;
        }
    }, flock.requireModule.paths = {
        webarraymath: "../third-party/webarraymath/js/webarraymath.js",
        Random: "../third-party/simjs/js/random-0.26.js"
    }, flock.noOp = function() {}, flock.isIterable = function(e) {
        var t = typeof e;
        return e && void 0 !== e.length && "string" !== t && "function" !== t;
    }, flock.hasValue = function(e, t) {
        var n = !1;
        for (var o in e) if (e[o] === t) {
            n = !0;
            break;
        }
        return n;
    }, flock.hasTag = function(e, t) {
        return !(!e || !t) && (e.tags && -1 < e.tags.indexOf(t));
    }, flock.randomValue = function(e, t) {
        var n = t - e;
        return Math.random() * n + e;
    }, flock.randomAudioValue = function() {
        return 2 * Math.random() - 1;
    }, flock.fillBuffer = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t(n, e);
        return e;
    }, flock.fillBufferWithValue = function(e, t) {
        for (var n = 0; n < e.length; n++) e[n] = t;
        return e;
    }, flock.generateBuffer = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBuffer(n, t);
    }, flock.generateBufferWithValue = function(e, t) {
        var n = new Float32Array(e);
        return flock.fillBufferWithValue(n, t);
    }, flock.generate = function(e, t) {
        var n = "number" == typeof e;
        return ("function" == typeof t ? n ? flock.generateBuffer : flock.fillBuffer : n ? flock.generateBufferWithValue : flock.fillBufferWithValue)(e, t);
    }, flock.generate.silence = function(e) {
        return new Float32Array(e);
    }, flock.clearBuffer = function(e) {
        for (var t = 0; t < e.length; t++) e[t] = 0;
        return e;
    }, flock.reverse = function(e) {
        if (!e || !flock.isIterable(e) || e.length < 2) return e;
        if ("function" == typeof e.reverse) return e.reverse();
        for (var t, n = 0, o = e.length - 1; n < o; n++, o--) t = e[n], e[n] = e[o], e[o] = t;
        return e;
    }, flock.randomIndex = function(e) {
        var t = e.length - 1;
        return Math.round(Math.random() * t);
    }, flock.arrayChoose = function(e, t) {
        return t = t || flock.randomIndex, (e = fluid.makeArray(e))[t(e)];
    }, flock.choose = function(e, t) {
        return flock.isIterable(e) ? flock.arrayChoose(e, t) : e[flock.arrayChoose(e.keys, t)];
    }, flock.shuffle = function(e) {
        for (var t = e.length - 1; 0 < t; t -= 1) {
            var n = Math.floor(Math.random() * (t + 1)), o = e[t];
            e[t] = e[n], e[n] = o;
        }
        return e;
    }, flock.normalize = function(e, t, n) {
        n = n || e;
        var o, r, a, i = 0;
        for (t = void 0 === t ? 1 : t, o = 0; o < e.length; o++) i < (r = Math.abs(e[o])) && (i = r);
        if (0 < i) for (o = 0; o < e.length; o++) a = e[o], n[o] = a / i * t;
        return n;
    }, flock.generateFourierTable = function(e, a, i, l, u) {
        return l *= flock.TWOPI, flock.generateBuffer(e, function(e) {
            var t, n, o, r = 0;
            for (t = 0; t < i; t++) n = u ? u[t] : 1, o = (t + 1) * (e * a), r += n * Math.cos(o + l);
            return r;
        });
    }, flock.generateNormalizedFourierTable = function(e, t, n, o, r) {
        var a = flock.generateBuffer(n, function(e) {
            return r(e + 1);
        }), i = flock.generateFourierTable(e, t, n, o, a);
        return flock.normalize(i);
    }, flock.fillTable = function(e, t) {
        var n = "number" == typeof e ? e : e.length;
        return t(e, flock.TWOPI / n);
    }, flock.tableGenerators = {
        sin: function(e, t) {
            return flock.generateBuffer(e, function(e) {
                return Math.sin(e * t);
            });
        },
        tri: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 1e3, 1, function(e) {
                return e % 2 == 0 ? 0 : 1 / (e * e);
            });
        },
        saw: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return 1 / e;
            });
        },
        square: function(e, t) {
            return flock.generateNormalizedFourierTable(e, t, 10, -.25, function(e) {
                return e % 2 == 0 ? 0 : 1 / e;
            });
        },
        hann: function(n) {
            return flock.generateBuffer(n, function(e) {
                var t = Math.sin(Math.PI * e / n);
                return t * t;
            });
        },
        sinWindow: function(t) {
            return flock.generateBuffer(t, function(e) {
                return Math.sin(Math.PI * e / t);
            });
        }
    }, flock.range = function(e) {
        var t, n, o = {
            max: Number.NEGATIVE_INFINITY,
            min: 1 / 0
        };
        for (t = 0; t < e.length; t++) (n = e[t]) > o.max && (o.max = n), n < o.min && (o.min = n);
        return o;
    }, flock.scale = function(e) {
        if (e) {
            var t, n = flock.range(e), o = (n.max - n.min) / 2, r = (n.max + n.min) / 2;
            for (t = 0; t < e.length; t++) e[t] = (e[t] - r) / o;
            return e;
        }
    }, flock.copyBuffer = function(e, t, n) {
        void 0 === n && (n = e.length);
        var o, r, a = new Float32Array(n - t);
        for (o = t, r = 0; o < n; o++, r++) a[r] = e[o];
        return a;
    }, flock.copyToBuffer = function(e, t) {
        for (var n = Math.min(e.length, t.length), o = 0; o < n; o++) t[o] = e[o];
    }, flock.parseMidiString = function(e) {
        if (!e || e.length < 2) return NaN;
        var t = (e = e.toLowerCase()).charAt(1), n = "#" === t || "b" === t ? 2 : 1, o = e.substring(0, n);
        return 12 * Number(e.substring(n)) + flock.midiFreq.noteNames[o];
    }, flock.midiFreq = function(e, t, n, o) {
        return t = void 0 === t ? 440 : t, n = void 0 === n ? 69 : n, o = o || 12, "string" == typeof e && (e = flock.parseMidiString(e)), 
        t * Math.pow(2, 1 * (e - n) / o);
    }, flock.midiFreq.noteNames = {
        "b#": 0,
        c: 0,
        "c#": 1,
        db: 1,
        d: 2,
        "d#": 3,
        eb: 3,
        e: 4,
        "e#": 5,
        f: 5,
        "f#": 6,
        gb: 6,
        g: 7,
        "g#": 8,
        ab: 8,
        a: 9,
        "a#": 10,
        bb: 10,
        b: 11,
        cb: 11
    }, flock.interpolate = {
        none: function(e, t) {
            return t[0 | (e %= t.length)];
        },
        linear: function(e, t) {
            var n = t.length, o = 0 | (e %= n), r = (o + 1) % n, a = e - o, i = t[o];
            return i + a * (t[r] - i);
        },
        hermite: function(e, t) {
            var n = t.length, o = Math.floor(e), r = o % n, a = e - o, i = (r + 1) % n, l = (r + 2) % n, u = t[0 < r ? r - 1 : n - 1], s = t[r], f = t[i], c = .5 * (f - u), d = s - f, m = c + d, h = m + d + .5 * (t[l] - s);
            return ((h * a - (m + h)) * a + c) * a + s;
        }
    }, flock.interpolate.cubic = flock.interpolate.hermite, flock.log = {
        fail: function(e) {
            fluid.log(fluid.logLevel.FAIL, e);
        },
        warn: function(e) {
            fluid.log(fluid.logLevel.WARN, e);
        },
        debug: function(e) {
            fluid.log(fluid.logLevel.INFO, e);
        }
    }, flock.fail = function(e) {
        if (flock.debug.failHard) throw e = e instanceof Error ? e : new Error(e);
        flock.log.fail(e);
    }, flock.pathParseError = function(e, t, n) {
        var o = "Error parsing path '" + t + "'. Segment '" + n + "' could not be resolved.";
        flock.fail(o);
    }, flock.get = function(e, t) {
        if (!e) return fluid.getGlobalValue(t);
        if (1 === arguments.length && "string" == typeof e) return fluid.getGlobalValue(e);
        if (t && "" !== t) {
            var n, o = "" === t ? [] : String(t).split("."), r = e[o[0]];
            for (n = 1; n < o.length; n++) {
                if (null == r) return void flock.pathParseError(e, t, o[n - 1]);
                r = r[o[n]];
            }
            return r;
        }
    }, flock.set = function(e, t, n) {
        if (e && t && "" !== t) {
            var o, r = String(t).split("."), a = r.length, i = r[0];
            for (o = 1; o < a; o++) {
                if ("object" !== typeof (e = e[i])) return void flock.fail("Error while setting a value at path '" + t + "'. A non-container object was found at segment '" + i + "'. Value: " + e);
                void 0 === e[i = r[o]] && (e[i] = {});
            }
            return e[i] = n;
        }
    }, flock.invoke = function(e, t, n) {
        var o = "function" == typeof e ? e : flock.get(e, t);
        if ("function" == typeof o) return o.apply(null, n);
        flock.fail("Path '" + t + "' does not resolve to a function.");
    }, flock.input = {}, flock.input.shouldExpand = function(e) {
        return flock.parse.specialInputs.indexOf(e) < 0;
    }, flock.input.pathExpander = function(e) {
        var t, n = fluid.model.parseEL(e), o = n.length - 1, r = [];
        for (t = 0; t < o; t++) {
            var a = n[t], i = n[t + 1];
            if (r.push(a), "model" === i || "options" === i) {
                r = r.concat(n.slice(t + 1, o));
                break;
            }
            isNaN(Number(i)) && r.push("inputs");
        }
        return r.push(n[o]), r.join(".");
    }, flock.input.expandPaths = function(e) {
        var t, n, o, r = {};
        for (t in e) n = flock.input.pathExpander(t), o = e[t], r[n] = o;
        return r;
    }, flock.input.expandPath = function(e) {
        return "string" == typeof e ? flock.input.pathExpander(e) : flock.input.expandPaths(e);
    }, flock.input.getValueForPath = function(e, t) {
        t = flock.input.expandPath(t);
        var n = flock.get(e, t);
        return flock.hasTag(n, "flock.ugen.valueType") ? n.inputs.value : n;
    }, flock.input.getValuesForPathArray = function(e, t) {
        var n, o, r = {};
        for (n = 0; n < t.length; n++) r[o = t[n]] = flock.input.get(e, o);
        return r;
    }, flock.input.getValuesForPathObject = function(e, t) {
        var n;
        for (n in t) t[n] = flock.input.get(e, n);
        return t;
    }, flock.input.get = function(e, t) {
        return "string" == typeof t ? flock.input.getValueForPath(e, t) : flock.isIterable(t) ? flock.input.getValuesForPathArray(e, t) : flock.input.getValuesForPathObject(e, t);
    }, flock.input.resolveValue = function(e, t, n, o, r, a, i) {
        if ("string" == typeof n) {
            var l = fluid.extractEL(n, flock.input.valueExpressionSpec);
            if (l) {
                var u = flock.input.getValueForPath(e, l);
                return void 0 === u && flock.log.debug("The value expression '" + n + "' resolved to undefined. If this isn't expected, check to ensure that your path is valid."), 
                u;
            }
        }
        return flock.input.shouldExpand(r) && i ? i(n, t, o, a) : n;
    }, flock.input.valueExpressionSpec = {
        ELstyle: "${}"
    }, flock.input.setValueForPath = function(e, t, n, o, r) {
        t = flock.input.expandPath(t);
        var a = flock.get(e, t), i = t.lastIndexOf("."), l = t.slice(i + 1), u = -1 < i ? flock.get(e, t.slice(0, t.lastIndexOf(".inputs"))) : o, s = flock.input.resolveValue(e, t, n, u, l, a, r);
        return flock.set(e, t, s), u && u.onInputChanged && u.onInputChanged(l), s;
    }, flock.input.setValuesForPaths = function(e, t, n, o) {
        var r, a, i, l = {};
        for (r in t) a = t[r], i = flock.input.set(e, r, a, n, o), l[r] = i;
        return l;
    }, flock.input.set = function(e, t, n, o, r) {
        return "string" == typeof t ? flock.input.setValueForPath(e, t, n, o, r) : flock.input.setValuesForPaths(e, t, o, r);
    }, fluid.defaults("flock.audioSystem", {
        gradeNames: [ "fluid.modelComponent" ],
        channelRange: {
            min: 1,
            max: 32
        },
        outputBusRange: {
            min: 2,
            max: 1024
        },
        inputBusRange: {
            min: 1,
            max: 32
        },
        model: {
            rates: {
                audio: 44100,
                control: 689.0625,
                scheduled: 0,
                demand: 0,
                constant: 0
            },
            blockSize: 64,
            numBlocks: 16,
            chans: 2,
            numInputBuses: 2,
            numBuses: 8,
            bufferSize: "@expand:flock.audioSystem.defaultBufferSize()"
        },
        modelRelay: [ {
            target: "rates.control",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.rates.audio",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "numBlocks",
            singleTransform: {
                type: "fluid.transforms.binaryOp",
                left: "{that}.model.bufferSize",
                operator: "/",
                right: "{that}.model.blockSize"
            }
        }, {
            target: "chans",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.chans",
                min: "{that}.options.channelRange.min",
                max: "{that}.options.channelRange.max"
            }
        }, {
            target: "numInputBuses",
            singleTransform: {
                type: "fluid.transforms.limitRange",
                input: "{that}.model.numInputBuses",
                min: "{that}.options.inputBusRange.min",
                max: "{that}.options.inputBusRange.max"
            }
        }, {
            target: "numBuses",
            singleTransform: {
                type: "fluid.transforms.free",
                func: "flock.audioSystem.clampNumBuses",
                args: [ "{that}.model.numBuses", "{that}.options.outputBusRange", "{that}.model.chans" ]
            }
        } ]
    }), flock.audioSystem.clampNumBuses = function(e, t, n) {
        return e = Math.max(e, Math.max(n, t.min)), e = Math.min(e, t.max);
    }, flock.audioSystem.defaultBufferSize = function() {
        return flock.platform.isMobile ? 8192 : flock.platform.browser.mozilla ? 2048 : 1024;
    }, fluid.defaults("flock.busManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            nextAvailableBus: {
                input: 0,
                interconnect: 0
            }
        },
        members: {
            buses: {
                expander: {
                    funcName: "flock.enviro.createAudioBuffers",
                    args: [ "{audioSystem}.model.numBuses", "{audioSystem}.model.blockSize" ]
                }
            }
        },
        invokers: {
            acquireNextBus: {
                funcName: "flock.busManager.acquireNextBus",
                args: [ "{arguments}.0", "{that}.buses", "{that}.applier", "{that}.model", "{audioSystem}.model.chans", "{audioSystem}.model.numInputBuses" ]
            },
            reset: {
                changePath: "nextAvailableBus",
                value: {
                    input: 0,
                    interconnect: 0
                }
            }
        },
        listeners: {
            "onDestroy.reset": "{that}.reset()"
        }
    }), flock.busManager.acquireNextBus = function(e, t, n, o, r, a) {
        var i = o.nextAvailableBus[e];
        if (void 0 !== i) {
            var l = i + r, u = r + a;
            if ("interconnect" === e && (l += a, u = t.length), !(u <= l)) return n.change("nextAvailableBus." + e, ++i), 
            l;
            flock.fail("Unable to aquire a bus. There are insufficient buses available. Please use an existing bus or configure additional buses using the enviroment's numBuses and numInputBuses parameters.");
        } else flock.fail("An invalid bus type was specified when invoking flock.busManager.acquireNextBus(). Type was: " + e);
    }, fluid.defaults("flock.outputManager", {
        gradeNames: [ "fluid.modelComponent" ],
        model: {
            audioSettings: "{audioSystem}.model"
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            stop: "{that}.events.onStop.fire()",
            reset: "{that}.events.onReset.fire"
        },
        events: {
            onStart: "{enviro}.events.onStart",
            onStop: "{enviro}.events.onStop",
            onReset: "{enviro}.events.onReset"
        }
    }), fluid.defaults("flock.nodeListComponent", {
        gradeNames: "fluid.component",
        members: {
            nodeList: "@expand:flock.nodeList()"
        },
        invokers: {
            insert: "flock.nodeList.insert({that}.nodeList, {arguments}.0, {arguments}.1)",
            head: "flock.nodeList.head({that}.nodeList, {arguments}.0)",
            tail: "flock.nodeList.tail({that}.nodeList, {arguments}.0)",
            before: "flock.nodeList.before({that}.nodeList, {arguments}.0, {arguments}.1)",
            after: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)",
            remove: "flock.nodeList.remove({that}.nodeList, {arguments}.0)",
            replace: "flock.nodeList.after({that}.nodeList, {arguments}.0, {arguments}.1)"
        }
    }), fluid.defaults("flock.enviro", {
        gradeNames: [ "fluid.modelComponent", "flock.nodeListComponent", "fluid.resolveRootSingle" ],
        singleRootType: "flock.enviro",
        isGlobalSingleton: !0,
        members: {
            buffers: {},
            bufferSources: {}
        },
        components: {
            asyncScheduler: {
                type: "flock.scheduler.async"
            },
            audioSystem: {
                type: "flock.audioSystem"
            },
            busManager: {
                type: "flock.busManager"
            }
        },
        model: {
            isPlaying: !1
        },
        invokers: {
            gen: {
                funcName: "flock.enviro.gen",
                args: [ "{busManager}.buses", "{audioSystem}.model", "{that}.nodeList.nodes" ]
            },
            start: "flock.enviro.start({that}.model, {that}.events.onStart.fire)",
            play: "{that}.start",
            stop: "flock.enviro.stop({that}.model, {that}.events.onStop.fire)",
            reset: "{that}.events.onReset.fire()",
            registerBuffer: "flock.enviro.registerBuffer({arguments}.0, {that}.buffers)",
            releaseBuffer: "flock.enviro.releaseBuffer({arguments}.0, {that}.buffers)",
            saveBuffer: {
                funcName: "flock.enviro.saveBuffer",
                args: [ "{arguments}.0", "{that}.buffers", "{audioSystem}" ]
            }
        },
        events: {
            onStart: null,
            onPlay: "{that}.events.onStart",
            onStop: null,
            onReset: null
        },
        listeners: {
            onCreate: [ "flock.enviro.registerGlobalSingleton({that})" ],
            onStart: [ "{that}.applier.change(isPlaying, true)" ],
            onStop: [ "{that}.applier.change(isPlaying, false)" ],
            onReset: [ "{that}.stop()", "{asyncScheduler}.clearAll()", "flock.nodeList.clearAll({that}.nodeList)", "{busManager}.reset()", "fluid.clear({that}.buffers)" ]
        }
    }), flock.enviro.registerGlobalSingleton = function(e) {
        e.options.isGlobalSingleton && (flock.environment = flock.enviro.shared = e);
    }, flock.enviro.registerBuffer = function(e, t) {
        e.id && (t[e.id] = e);
    }, flock.enviro.releaseBuffer = function(e, t) {
        e && delete t["string" == typeof e ? e : e.id];
    }, flock.enviro.saveBuffer = function(e, t, n) {
        if ("string" == typeof e && (e = {
            buffer: e
        }), "string" == typeof e.buffer) {
            var o = e.buffer;
            e.buffer = t[o], e.buffer.id = o;
        }
        return e.type = e.type || "wav", e.path = e.path || e.buffer.id + "." + e.type, 
        e.format = e.format || "int16", n.bufferWriter.save(e, e.buffer);
    }, flock.enviro.gen = function(e, t, n) {
        flock.evaluate.clearBuses(e, t.numBuses, t.blockSize), flock.evaluate.synths(n);
    }, flock.enviro.start = function(e, t) {
        e.isPlaying || t();
    }, flock.enviro.stop = function(e, t) {
        e.isPlaying && t();
    }, flock.enviro.createAudioBuffers = function(e, t) {
        var n, o = [];
        for (n = 0; n < e; n++) o[n] = new Float32Array(t);
        return o;
    }, fluid.defaults("flock.autoEnviro", {
        gradeNames: [ "fluid.component" ],
        members: {
            enviro: "@expand:flock.autoEnviro.initEnvironment()"
        }
    }), flock.autoEnviro.initEnvironment = function() {
        return flock.environment ? flock.environment : flock.init();
    }, fluid.defaults("flock.silentEnviro", {
        gradeNames: "flock.enviro",
        listeners: {
            onCreate: [ "flock.silentEnviro.insertOutputGainNode({that})" ]
        }
    }), flock.silentEnviro.insertOutputGainNode = function(e) {
        e.audioSystem.nativeNodeManager && e.audioSystem.nativeNodeManager.createOutputNode({
            node: "Gain",
            params: {
                gain: 0
            }
        });
    }, fluid.defaults("flock.node", {
        gradeNames: [ "flock.autoEnviro", "fluid.modelComponent" ],
        addToEnvironment: "tail",
        model: {},
        components: {
            enviro: "{flock.enviro}"
        },
        invokers: {
            play: {
                funcName: "flock.node.play",
                args: [ "{that}", "{that}.enviro", "{that}.addToEnvironment" ]
            },
            pause: "{that}.removeFromEnvironment()",
            addToEnvironment: {
                funcName: "flock.node.addToEnvironment",
                args: [ "{that}", "{arguments}.0", "{that}.enviro.nodeList" ]
            },
            removeFromEnvironment: {
                funcName: "flock.node.removeFromEnvironment",
                args: [ "{that}", "{that}.enviro.nodeList" ]
            },
            isPlaying: {
                funcName: "flock.nodeList.isNodeActive",
                args: [ "{that}.enviro.nodeList", "{that}" ]
            }
        },
        listeners: {
            onCreate: [ "{that}.addToEnvironment({that}.options.addToEnvironment)" ],
            onDestroy: [ "{that}.removeFromEnvironment()" ]
        }
    }), flock.node.addToEnvironment = function(e, t, n) {
        if (void 0 === t && (t = e.options.addToEnvironment), null != t && !1 !== t) {
            var o = typeof t;
            "string" === o && "head" === t || "tail" === t ? flock.nodeList[t](n, e) : "number" === o ? flock.nodeList.insert(n, e, t) : flock.nodeList.tail(n, e);
        }
    }, flock.node.removeFromEnvironment = function(e, t) {
        flock.nodeList.remove(t, e);
    }, flock.node.play = function(e, t, n) {
        -1 === t.nodeList.nodes.indexOf(e) && n(e.options.addToEnvironment || "tail");
        t.model.isPlaying || t.play();
    }, fluid.defaults("flock.noteTarget", {
        gradeNames: "fluid.component",
        noteChanges: {
            on: {
                "env.gate": 1
            },
            off: {
                "env.gate": 0
            }
        },
        invokers: {
            set: {
                funcName: "fluid.notImplemented"
            },
            noteOn: {
                func: "{that}.events.noteOn.fire"
            },
            noteOff: {
                func: "{that}.events.noteOff.fire"
            },
            noteChange: {
                funcName: "flock.noteTarget.change",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            }
        },
        events: {
            noteOn: null,
            noteOff: null
        },
        listeners: {
            "noteOn.handleChange": [ "{that}.noteChange(on, {arguments}.0)" ],
            "noteOff.handleChange": [ "{that}.noteChange(off, {arguments}.0)" ]
        }
    }), flock.noteTarget.change = function(e, t, n) {
        var o = e.options.noteChanges[t], r = a.extend({}, o, n);
        e.set(r);
    }, fluid.defaults("flock.synth", {
        gradeNames: [ "flock.node", "flock.noteTarget" ],
        rate: flock.rates.AUDIO,
        addToEnvironment: !0,
        mergePolicy: {
            ugens: "nomerge"
        },
        ugens: {
            expander: {
                funcName: "flock.makeUGens",
                args: [ "{that}.options.synthDef", "{that}.rate", "{that}.nodeList", "{that}.enviro", "{that}.audioSettings" ]
            }
        },
        members: {
            rate: "{that}.options.rate",
            audioSettings: "{that}.enviro.audioSystem.model",
            nodeList: "@expand:flock.nodeList()",
            out: "{that}.options.ugens",
            genFn: "@expand:fluid.getGlobalValue(flock.evaluate.ugens)"
        },
        model: {
            blockSize: "@expand:flock.synth.calcBlockSize({that}.rate, {that}.enviro.audioSystem.model)"
        },
        invokers: {
            set: {
                funcName: "flock.synth.set",
                args: [ "{that}", "{that}.nodeList.namedNodes", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            get: {
                funcName: "flock.input.get",
                args: [ "{that}.nodeList.namedNodes", "{arguments}.0" ]
            },
            input: {
                funcName: "flock.synth.input",
                args: [ "{arguments}", "{that}.get", "{that}.set" ]
            }
        }
    }), flock.synth.createUGenTree = function(e, t, n) {
        return new flock.UGenTree(e, t, n);
    }, flock.synth.calcBlockSize = function(e, t) {
        return e === flock.rates.AUDIO ? t.blockSize : 1;
    }, flock.synth.set = function(r, e, t, n, a) {
        return flock.input.set(e, t, n, void 0, function(e, t, n, o) {
            return flock.synth.ugenValueParser(r, e, o, a);
        });
    }, flock.synth.input = function(e, t, n) {
        var o = e[0];
        return o ? "string" == typeof o ? e.length < 2 ? t(o) : n.apply(null, e) : flock.isIterable(o) ? t(o) : n.apply(null, e) : void 0;
    }, flock.synth.ugenValueParser = function(e, t, n, o) {
        if (null == t) return n;
        var r, a, i, l = flock.parse.ugenDef(t, e.enviro, {
            audioSettings: e.audioSettings,
            buses: e.enviro.busManager.buses,
            buffers: e.enviro.buffers
        }), u = flock.isIterable(l) ? l : void 0 !== l ? [ l ] : [], s = flock.isIterable(n) ? n : void 0 !== n ? [ n ] : [], f = Math.min(u.length, s.length), c = o ? "swapTree" : "replaceTree";
        for (r = 0; r < f; r++) a = flock.ugenNodeList[c](e.nodeList, u[r], s[r]);
        for (i = r; i < u.length; i++) a++, flock.ugenNodeList.insertTree(e.nodeList, u[i], a);
        for (i = r; i < s.length; i++) flock.ugenNodeList.removeTree(e.nodeList, s[i]);
        return l;
    }, fluid.defaults("flock.synth.value", {
        gradeNames: [ "flock.synth" ],
        rate: "demand",
        addToEnvironment: !1,
        invokers: {
            value: {
                funcName: "flock.evaluate.synthValue",
                args: [ "{that}" ]
            }
        }
    }), fluid.defaults("flock.synth.frameRate", {
        gradeNames: [ "flock.synth.value" ],
        rate: "scheduled",
        fps: 60,
        members: {
            audioSettings: {
                rates: {
                    scheduled: "{that}.options.fps"
                }
            }
        }
    }), flock.bufferDesc = function() {
        throw new Error("flock.bufferDesc is not defined. Did you forget to include the buffers.js file?");
    };
}();

var fluid = fluid || require("infusion");

(flock = fluid.registerNamespace("flock")).nodeList = function() {
    return {
        nodes: [],
        namedNodes: {}
    };
}, flock.nodeList.insert = function(e, t, n) {
    return n < 0 && (n = 0), e.nodes.splice(n, 0, t), flock.nodeList.registerNode(e, t), 
    n;
}, flock.nodeList.registerNode = function(e, t) {
    var n = t.name || t.id;
    n && (e.namedNodes[n] = t);
}, flock.nodeList.head = function(e, t) {
    return flock.nodeList.insert(e, t, 0);
}, flock.nodeList.before = function(e, t, n) {
    var o = e.nodes.indexOf(n);
    return flock.nodeList.insert(e, t, o);
}, flock.nodeList.after = function(e, t, n) {
    var o = e.nodes.indexOf(n) + 1;
    return flock.nodeList.insert(e, t, o);
}, flock.nodeList.tail = function(e, t) {
    var n = e.nodes.length;
    return flock.nodeList.insert(e, t, n);
}, flock.nodeList.unregisterNode = function(e, t) {
    var n = t.name || t.id;
    n && delete e.namedNodes[n];
}, flock.nodeList.isNodeActive = function(e, t) {
    return -1 < e.nodes.indexOf(t);
}, flock.nodeList.remove = function(e, t) {
    if (e) {
        var n = e.nodes.indexOf(t);
        return -1 < n && (e.nodes.splice(n, 1), flock.nodeList.unregisterNode(e, t)), n;
    }
}, flock.nodeList.replace = function(e, t, n) {
    var o = e.nodes.indexOf(n);
    return o < 0 ? flock.nodeList.tail(e, t) : (e.nodes[o] = t, flock.nodeList.unregisterNode(e, n), 
    flock.nodeList.registerNode(e, t), o);
}, flock.nodeList.clearAll = function(e) {
    for (var t in e.nodes.length = 0, e.namedNodes) delete e.namedNodes[t];
}, flock.ugenNodeList = function() {
    return flock.nodeList();
}, flock.ugenNodeList.insertTree = function(e, t, n) {
    var o, r, a = t.inputs;
    for (o in a) r = a[o], flock.isUGen(r) && (n = flock.ugenNodeList.insertTree(e, r, n), 
    n++);
    return flock.nodeList.insert(e, t, n);
}, flock.ugenNodeList.removeTree = function(e, t) {
    var n, o, r = t.inputs;
    for (n in r) o = r[n], flock.isUGen(o) && flock.ugenNodeList.removeTree(e, o);
    return flock.nodeList.remove(e, t);
}, flock.ugenNodeList.tailTree = function(e, t) {
    var n = e.nodes.length;
    return flock.ugenNodeList.insertTree(e, t, n);
}, flock.ugenNodeList.replaceTree = function(e, t, n) {
    if (!n) return flock.ugenNodeList.tailTree(e, t);
    var o = flock.ugenNodeList.removeTree(e, n);
    return flock.ugenNodeList.insertTree(e, t, o), o;
}, flock.ugenNodeList.swapTree = function(e, t, n, o) {
    return o ? (flock.ugenNodeList.reattachInputs(e, t, n, o), flock.ugenNodeList.replaceInputs(e, t, n, o)) : t.inputs = n.inputs, 
    flock.nodeList.replace(e, t, n);
}, flock.ugenNodeList.reattachInputs = function(e, t, n, o) {
    for (var r in n.inputs) o.indexOf(r) < 0 ? flock.ugenNodeList.removeTree(e, n.inputs[r]) : t.inputs[r] = n.inputs[r];
}, flock.ugenNodeList.replaceInputs = function(e, t, n, o) {
    for (var r in t.inputs) o.indexOf(r) < 0 && flock.ugenNodeList.replaceTree(e, t.inputs[r], n.inputs[r]);
}, flock.makeUGens = function(e, t, n, o, r) {
    e || fluid.log(fluid.logLevel.IMPORTANT, "Warning: An empy synthDef was found while instantiating a unit generator tree.Did you forget to include a 'synthDef' option for your Synth?");
    var a = t === flock.rates.SCHEDULED || t === flock.rates.DEMAND;
    return flock.parse.synthDef(e, o, {
        rate: t,
        overrideRate: a,
        visitors: [ flock.makeUGens.visitor(n) ],
        buffers: o.buffers,
        buses: o.busManager.buses,
        audioSettings: r || o.audioSystem.model
    });
}, flock.makeUGens.visitor = function(t) {
    return function(e) {
        flock.nodeList.tail(t, e);
    };
};

fluid = fluid || require("infusion");

(flock = fluid.registerNamespace("flock")).evaluate = {
    synth: function(e) {
        e.genFn(e.nodeList.nodes), e.out && (e.model.value = e.out.model.value);
    },
    synthValue: function(e) {
        return flock.evaluate.synth(e), e.model.value;
    },
    synths: function(e) {
        for (var t = 0; t < e.length; t++) flock.evaluate.synth(e[t]);
    },
    clearBuses: function(e, t, n) {
        for (var o = 0; o < t; o++) for (var r = e[o], a = 0; a < n; a++) r[a] = 0;
    },
    ugens: function(e) {
        for (var t, n = 0; n < e.length; n++) void 0 !== (t = e[n]).gen && t.gen(t.model.blockSize);
    }
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.modelSynth", {
    gradeNames: "flock.synth",
    model: {
        inputs: {}
    },
    modelListeners: {
        inputs: [ {
            funcName: "flock.modelSynth.updateUGens",
            args: [ "{that}.set", "{that}.options.ugens", "{change}" ]
        } ]
    },
    invokers: {
        value: "{that}.events.onEvaluate.fire()"
    },
    events: {
        onEvaluate: null
    },
    listeners: {
        onEvaluate: [ "{that}.genFn({that}.nodeList.nodes)", {
            changePath: "value",
            value: "{that}.out.model.value"
        } ]
    }
}), flock.modelSynth.updateUGens = function(e, t, n) {
    var o = {};
    flock.modelSynth.flattenModel("", n.value, o), e(o);
}, flock.modelSynth.shouldFlattenValue = function(e) {
    return fluid.isPrimitive(e) || flock.isIterable(e) || e.ugen;
}, flock.modelSynth.flattenModel = function(e, t, n) {
    for (var o in t) {
        var r = t[o], a = fluid.pathUtil.composePath(e, o.toString());
        flock.modelSynth.shouldFlattenValue(r) ? n[a] = r : flock.modelSynth.flattenModel(a, r, n);
    }
    return n;
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.synth.group", {
    gradeNames: [ "flock.node", "flock.noteTarget" ],
    methodEventMap: {
        onSet: "set"
    },
    members: {
        nodeList: "@expand:flock.nodeList()",
        genFn: "@expand:fluid.getGlobalValue(flock.evaluate.synths)"
    },
    invokers: {
        play: "{that}.events.onPlay.fire",
        pause: "{that}.events.onPause.fire",
        set: "{that}.events.onSet.fire",
        get: "flock.synth.group.get({arguments}, {that}.nodeList.nodes)",
        head: "flock.synth.group.head({arguments}.0, {that})",
        tail: "flock.synth.group.tail({arguments}.0, {that})",
        insert: "flock.synth.group.insert({arguments}.0, {arguments}.1, {that})",
        before: "flock.synth.group.before({arguments}.0, {arguments}.1, {that})",
        after: "flock.synth.group.after({arguments}.0, {arguments}.1, {that})",
        remove: "{that}.events.onRemove.fire",
        input: {
            funcName: "flock.synth.group.input",
            args: [ "{arguments}", "{that}.get", "{that}.events.onSet.fire" ]
        }
    },
    events: {
        onSet: null,
        onGen: null,
        onPlay: null,
        onPause: null,
        onInsert: null,
        onRemove: null
    },
    listeners: {
        onInsert: [ {
            funcName: "flock.synth.group.bindMethods",
            args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "addListener" ]
        }, "flock.synth.group.removeNodeFromEnvironment({arguments}.0)" ],
        onRemove: [ {
            funcName: "flock.synth.group.bindMethods",
            args: [ "{arguments}.0", "{that}.options.methodEventMap", "{that}.events", "removeListener" ]
        }, {
            this: "{that}.nodeList",
            method: "remove",
            args: [ "{arguments}.0" ]
        } ]
    }
}), flock.synth.group.head = function(e, t) {
    flock.nodeList.head(t.nodeList, e), t.events.onInsert.fire(e);
}, flock.synth.group.tail = function(e, t) {
    flock.nodeList.tail(t.nodeList, e), t.events.onInsert.fire(e);
}, flock.synth.group.insert = function(e, t, n) {
    flock.nodeList.insert(n.nodeList, e, t), n.events.onInsert.fire(e);
}, flock.synth.group.before = function(e, t, n) {
    flock.nodeList.before(n.nodeList, e, t), n.events.onInsert.fire(e);
}, flock.synth.group.after = function(e, t, n) {
    flock.nodeList.after(n.nodeList, e, t), n.events.onInsert.fire(e);
}, flock.synth.group.removeNodeFromEnvironment = function(e) {
    e.removeFromEnvironment();
}, flock.synth.group.get = function(e, t) {
    var n = t[t.length - 1];
    return n.get.apply(n, e);
}, flock.synth.group.input = function(e, t, n) {
    return (1 < e.length ? n : t).apply(null, e);
}, flock.synth.group.bindMethods = function(e, t, n, o) {
    for (var r in t) {
        var a = e[t[r]];
        (0, n[r][o])(a);
    }
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var i = fluid.registerNamespace("jQuery");
    fluid.defaults("flock.synth.polyphonic", {
        gradeNames: [ "flock.synth.group" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        noteSpecs: "{that}.options.noteChanges",
        distributeOptions: {
            source: "{that}.options.voiceAllocatorOptions",
            target: "{that flock.synth.voiceAllocator}.options",
            removeSource: !0
        },
        voiceAllocatorOptions: {
            synthDef: "{polyphonic}.options.synthDef",
            maxVoices: "{polyphonic}.options.maxVoices",
            amplitudeNormalizer: "{polyphonic}.options.amplitudeNormalizer",
            amplitudeKey: "{polyphonic}.options.amplitudeKey",
            listeners: {
                onCreateVoice: {
                    funcName: "flock.nodeList.tail",
                    args: [ "{polyphonic}.nodeList", "{arguments}.0" ]
                }
            }
        },
        components: {
            voiceAllocator: {
                type: "flock.synth.voiceAllocator.lazy"
            }
        },
        invokers: {
            noteChange: {
                funcName: "flock.synth.polyphonic.noteChange",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            createVoice: {
                func: "{voiceAllocator}.createVoice",
                args: [ "{that}.options", "{that}.insert" ]
            }
        },
        listeners: {
            "noteOn.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOn",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ],
            "noteOff.handleChange": [ {
                funcName: "flock.synth.polyphonic.noteOff",
                args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
            } ]
        }
    }), flock.synth.polyphonic.noteChange = function(e, t, n, o) {
        var r = e.options.noteChanges[t], a = i.extend({}, r, o);
        n.set(a);
    }, flock.synth.polyphonic.noteOn = function(e, t, n) {
        var o = e.voiceAllocator.getFreeVoice();
        return e.voiceAllocator.activeVoices[t] && e.noteOff(t), e.voiceAllocator.activeVoices[t] = o, 
        e.noteChange("on", o, n), o;
    }, flock.synth.polyphonic.noteOff = function(e, t, n) {
        var o = e.voiceAllocator.activeVoices[t];
        return o ? (e.noteChange("off", o, n), delete e.voiceAllocator.activeVoices[t], 
        e.voiceAllocator.freeVoices.push(o), o) : null;
    }, fluid.defaults("flock.synth.voiceAllocator", {
        gradeNames: [ "fluid.component" ],
        maxVoices: 16,
        amplitudeNormalizer: "static",
        amplitudeKey: "env.sustain",
        members: {
            activeVoices: {},
            freeVoices: []
        },
        invokers: {
            createVoice: {
                funcName: "flock.synth.voiceAllocator.createVoice",
                args: [ "{that}.options", "{that}.events.onCreateVoice.fire" ]
            }
        },
        events: {
            onCreateVoice: null
        }
    }), flock.synth.voiceAllocator.createVoice = function(e, t) {
        var n, o = flock.synth({
            synthDef: e.synthDef,
            addToEnvironment: !1
        }), r = e.amplitudeNormalizer, a = e.amplitudeKey;
        return r && ("function" == typeof r ? r(o, a) : "static" === r && (n = 1 / e.maxVoices, 
        o.input(a, n))), t(o), o;
    }, fluid.defaults("flock.synth.voiceAllocator.lazy", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: {
                funcName: "flock.synth.voiceAllocator.lazy.get",
                args: [ "{that}.freeVoices", "{that}.activeVoices", "{that}.createVoice", "{that}.options.maxVoices" ]
            }
        }
    }), flock.synth.voiceAllocator.lazy.get = function(e, t, n, o) {
        return 1 < e.length ? e.pop() : Object.keys(t).length > o ? null : n();
    }, fluid.defaults("flock.synth.voiceAllocator.pool", {
        gradeNames: [ "flock.synth.voiceAllocator" ],
        invokers: {
            getFreeVoice: "flock.synth.voiceAllocator.pool.get({that}.freeVoices)"
        }
    }), flock.synth.voiceAllocator.pool.get = function(e) {
        if (0 < e.length) return e.pop();
    }, flock.synth.voiceAllocator.pool.allocateVoices = function(e, t, n) {
        for (var o = 0; o < n; o++) e[o] = t();
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.band", {
    gradeNames: [ "fluid.component" ],
    synthGrade: "flock.noteTarget",
    invokers: {
        play: {
            func: "{that}.events.onPlay.fire"
        },
        pause: {
            func: "{that}.events.onPause.fire"
        },
        set: {
            func: "{that}.events.onSet.fire"
        },
        getSynths: {
            funcName: "fluid.queryIoCSelector",
            args: [ "{that}", "{that}.options.synthGrade" ]
        }
    },
    events: {
        onPlay: null,
        onPause: null,
        onSet: null
    },
    distributeOptions: [ {
        source: "{that}.options.synthListeners",
        removeSource: !0,
        target: "{that flock.synth}.options.listeners"
    } ],
    synthListeners: {
        "{band}.events.onPlay": {
            func: "{that}.play"
        },
        "{band}.events.onPause": {
            func: "{that}.pause"
        },
        "{band}.events.onSet": {
            func: "{that}.set"
        }
    }
});

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    function e() {
        var r = [], o = {
            state: "pending",
            value: void 0,
            resolve: function(e) {
                t("resolve", e), o.state = "fulfilled";
            },
            reject: function(e) {
                t("reject", e), o.state = "rejected";
            },
            then: function(e, t) {
                r ? r.push({
                    resolve: e,
                    reject: t
                }) : ("fulfilled" === o.state ? e : t)(o.value);
                return this;
            },
            safe: {
                then: function(e, t) {
                    return o.then(e, t), this;
                }
            }
        };
        function t(e, n) {
            o.value = n, o.then = "reject" === e ? function(e, t) {
                return t(n), this;
            } : function(e) {
                return e(n), this;
            }, o.resolve = o.reject = function() {
                throw new Error("Promise already completed");
            }, function(e, t) {
                var n, o;
                for (n = 0; n < r.length; n++) (o = r[n])[e] && o[e](t);
                r = null;
            }(e, n);
        }
        return o;
    }
    fluid.defaults("flock.promise", {
        gradeNames: [ "fluid.component" ],
        members: {
            promise: {
                expander: {
                    funcName: "flock.promise.make"
                }
            }
        }
    }), flock.promise.make = function() {
        return new e();
    }, flock.bufferDesc = function(e, t, n) {
        return (flock.platform.isWebAudio && e instanceof AudioBuffer ? flock.bufferDesc.fromAudioBuffer : flock.isIterable(e) ? flock.bufferDesc.fromChannelArray : flock.bufferDesc.expand)(e, t, n);
    }, flock.bufferDesc.inferFormat = function(e, t, n) {
        var o = e.format, r = e.data;
        return o.sampleRate = t || o.sampleRate || 44100, o.numChannels = n || o.numChannels || e.data.channels.length, 
        o.numSampleFrames = o.numSampleFrames || 0 < r.channels.length ? r.channels[0].length : 0, 
        o.duration = o.numSampleFrames / o.sampleRate, e;
    }, flock.bufferDesc.fromChannelArray = function(e, t, n) {
        e instanceof Float32Array && (e = [ e ]);
        var o = {
            container: {},
            format: {
                numChannels: n,
                sampleRate: t,
                numSampleFrames: e[0].length
            },
            data: {
                channels: e
            }
        };
        return flock.bufferDesc.inferFormat(o, t, n);
    }, flock.bufferDesc.expand = function(e, t, n) {
        if ((e = e || {
            data: {
                channels: []
            }
        }).container = e.container || {}, e.format = e.format || {}, e.format.numChannels = n || e.format.numChannels || e.data.channels.length, 
        e.data && e.data.channels && (1 === e.format.numChannels && 1 !== e.data.channels.length && (e.data.channels = [ e.data.channels ]), 
        e.format.numChannels !== e.data.channels.length)) throw new Error("The specified number of channels does not match the actual channel data. numChannels was: " + e.format.numChannels + " but the sample data contains " + e.data.channels.length + " channels.");
        return flock.bufferDesc.inferFormat(e, t, n);
    }, flock.bufferDesc.fromAudioBuffer = function(e) {
        var t, n = {
            container: {},
            format: {
                sampleRate: e.sampleRate,
                numChannels: e.numberOfChannels,
                numSampleFrames: e.length,
                duration: e.duration
            },
            data: {
                channels: []
            }
        };
        for (t = 0; t < e.numberOfChannels; t++) n.data.channels.push(e.getChannelData(t));
        return n;
    }, flock.bufferDesc.toAudioBuffer = function(e, t) {
        for (var n = e.createBuffer(t.format.numChannels, t.format.numSampleFrames, t.format.sampleRate), o = 0; o < t.format.numChannels; o++) n.copyToChannel(t.data.channels[o], o);
        return n;
    }, fluid.defaults("flock.bufferSource", {
        gradeNames: [ "fluid.modelComponent" ],
        sampleRate: "{enviro}.audioSystem.model.sampleRate",
        model: {
            state: "start",
            src: null
        },
        components: {
            bufferPromise: {
                createOnEvent: "onRefreshPromise",
                type: "flock.promise",
                options: {
                    listeners: {
                        onCreate: {
                            this: "{that}.promise",
                            method: "then",
                            args: [ "{bufferSource}.events.afterFetch.fire", "{bufferSource}.events.onError.fire" ]
                        }
                    }
                }
            }
        },
        invokers: {
            get: {
                funcName: "flock.bufferSource.get",
                args: [ "{that}", "{arguments}.0" ]
            },
            set: {
                funcName: "flock.bufferSource.set",
                args: [ "{that}", "{arguments}.0" ]
            },
            error: {
                funcName: "flock.bufferSource.error",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            onCreate: {
                funcName: "{that}.events.onRefreshPromise.fire"
            },
            onRefreshPromise: {
                changePath: "state",
                value: "start"
            },
            onFetch: {
                changePath: "state",
                value: "in-progress"
            },
            afterFetch: [ {
                changePath: "state",
                value: "fetched"
            }, {
                funcName: "{that}.events.onBufferUpdated.fire",
                args: [ "{arguments}.0" ]
            } ],
            onBufferUpdated: "{enviro}.registerBuffer({arguments}.0)",
            onError: {
                changePath: "state",
                value: "error"
            }
        },
        events: {
            onRefreshPromise: null,
            onError: null,
            onFetch: null,
            afterFetch: null,
            onBufferUpdated: null
        }
    }), flock.bufferSource.get = function(t, n) {
        return "in-progress" === t.model.state || n.src === t.model.src && !n.replace || n.src && ("fetched" !== t.model.state && "errored" !== t.model.state || t.model.src === n.src && !n.replace || t.events.onRefreshPromise.fire(), 
        "start" === t.model.state && (t.model.src = n.src, t.events.onFetch.fire(n), flock.audio.decode({
            src: n.src,
            sampleRate: t.options.sampleRate,
            success: function(e) {
                n.id && (e.id = n.id), t.set(e);
            },
            error: t.error
        }))), t.bufferPromise.promise;
    }, flock.bufferSource.set = function(e, t) {
        var n = e.model.state;
        return "start" !== n && "in-progress" !== n || e.bufferPromise.promise.resolve(t), 
        e.bufferPromise.promise;
    }, flock.bufferSource.error = function(e, t) {
        return e.bufferPromise.promise.reject(t), e.bufferPromise.promise;
    }, fluid.defaults("flock.bufferLoader", {
        gradeNames: [ "fluid.component" ],
        bufferDefs: [],
        members: {
            buffers: [],
            bufferDefs: "@expand:flock.bufferLoader.expandBufferDefs({that}.options.bufferDefs)"
        },
        components: {
            enviro: "{flock.enviro}"
        },
        events: {
            afterBuffersLoaded: null,
            onError: null
        },
        listeners: {
            "onCreate.loadBuffers": {
                funcName: "flock.bufferLoader.loadBuffers",
                args: [ "{that}" ]
            },
            "onError.logError": {
                funcName: "flock.log.fail"
            }
        }
    }), flock.bufferLoader.idFromURL = function(e) {
        var t = e.lastIndexOf("/"), n = -1 < t ? t + 1 : 0, o = e.lastIndexOf("."), r = -1 < o ? o : e.length;
        return e.substring(n, r);
    }, flock.bufferLoader.idsFromURLs = function(e) {
        return fluid.transform(e, flock.bufferLoader.idFromURL);
    }, flock.bufferLoader.expandFileSequence = function(e) {
        e = e || [];
        var t, n, o, r = [];
        for (t = 0; t < e.length; t++) n = e[t], o = flock.bufferLoader.idFromURL(n), r.push({
            id: o,
            url: n
        });
        return r;
    }, flock.bufferLoader.expandBufferDef = function(e) {
        return "string" == typeof e && (e = {
            url: e
        }), void 0 === e.id && void 0 !== e.url && (e.id = flock.bufferLoader.idFromURL(e.url)), 
        e;
    }, flock.bufferLoader.expandBufferDefs = function(e) {
        return e ? (e = fluid.makeArray(e), fluid.transform(e, flock.bufferLoader.expandBufferDef)) : [];
    }, flock.bufferLoader.loadBuffer = function(e, t, n) {
        try {
            flock.parse.bufferForDef(e, t, n.enviro);
        } catch (e) {
            n.events.onError.fire(e.message);
        }
    }, flock.bufferLoader.loadBuffers = function(n) {
        var o = 1, r = {
            setBuffer: function(e) {
                if (n.buffers.push(e), n.buffers.length === n.options.bufferDefs.length) n.events.afterBuffersLoaded.fire(n.buffers); else if (o < n.bufferDefs.length) {
                    var t = n.bufferDefs[o];
                    flock.bufferLoader.loadBuffer(t, r, n), o++;
                }
            }
        };
        flock.bufferLoader.loadBuffer(n.bufferDefs[0], r, n);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var m = fluid.registerNamespace("jQuery");
    fluid.registerNamespace("flock.parse"), flock.parse.synthDef = function(e, t, n) {
        return e || (e = []), flock.parse.synthDef.hasOutUGen(e) || (e = flock.parse.synthDef.makeOutUGenDef(e, n)), 
        flock.parse.ugenForDef(e, t, n);
    }, flock.parse.synthDef.hasOutUGen = function(e) {
        return !flock.isIterable(e) && (e.id === flock.OUT_UGEN_ID || "flock.ugen.out" === e.ugen || "flock.ugen.valueOut" === e.ugen);
    }, flock.parse.synthDef.makeOutUGenDef = function(e, t) {
        return e = {
            id: flock.OUT_UGEN_ID,
            ugen: "flock.ugen.valueOut",
            inputs: {
                sources: e
            }
        }, t.rate === flock.rates.AUDIO && (e.ugen = "flock.ugen.out", e.inputs.bus = 0, 
        e.inputs.expand = t.audioSettings.chans), e;
    }, flock.parse.makeUGen = function(e, t, n, o) {
        var r, a = o.audioSettings.rates, i = o.audioSettings.blockSize;
        if (e.rate || (e.rate = flock.rates.AUDIO), !flock.hasValue(flock.rates, e.rate) && (flock.fail("An invalid rate was specified for a unit generator. ugenDef was: " + fluid.prettyPrintJSON(e)), 
        !flock.debug.failHard)) {
            var l = e.rate;
            e.rate = flock.rates.AUDIO, flock.log.warn("Overriding invalid unit generator rate. Rate is now '" + e.rate + "'; was: " + fluid.prettyPrintJSON(l));
        }
        r = e.options && void 0 !== e.options.sampleRate ? e.options.sampleRate : a[e.rate], 
        e.options = m.extend(!0, {}, e.options, {
            sampleRate: r,
            rate: e.rate,
            audioSettings: {
                rates: a,
                blockSize: i
            }
        });
        var u, s = e.rate === flock.rates.AUDIO ? i : 1;
        if (flock.hasTag(e.options, "flock.ugen.multiChannelOutput")) {
            var f = e.options.numOutputs || 1;
            u = [];
            for (var c = 0; c < f; c++) u.push(new Float32Array(s));
        } else u = new Float32Array(s);
        var d = fluid.copy(e.options);
        return d.buffers = o.buffers, d.buses = o.buses, d.enviro = n, flock.invoke(void 0, e.ugen, [ t, u, d ]);
    }, flock.parse.reservedWords = [ "id", "ugen", "rate", "inputs", "options" ], flock.parse.specialInputs = [ "value", "buffer", "list", "table", "envelope", "durations", "values" ], 
    flock.parse.expandInputs = function(e) {
        if (e.inputs) return e;
        var t, n = {};
        for (t in e) -1 === flock.parse.reservedWords.indexOf(t) && (n[t] = e[t], delete e[t]);
        return e.inputs = n, e;
    }, flock.parse.ugenDefForConstantValue = function(e) {
        return {
            ugen: "flock.ugen.value",
            rate: flock.rates.CONSTANT,
            inputs: {
                value: e
            }
        };
    }, flock.parse.expandValueDef = function(e) {
        var t = typeof e;
        if ("number" === t) return flock.parse.ugenDefForConstantValue(e);
        if ("object" === t) return e;
        throw new Error("Invalid value type found in ugen definition. UGenDef was: " + fluid.prettyPrintJSON(e));
    }, flock.parse.rateMap = {
        ar: flock.rates.AUDIO,
        kr: flock.rates.CONTROL,
        sr: flock.rates.SCHEDULED,
        dr: flock.rates.DEMAND,
        cr: flock.rates.CONSTANT
    }, flock.parse.expandRate = function(e, t) {
        return e.rate = flock.parse.rateMap[e.rate] || e.rate, t.overrideRate && e.rate !== flock.rates.CONSTANT && (e.rate = t.rate), 
        e;
    }, flock.parse.ugenDef = function(e, t, n) {
        return (flock.isIterable(e) ? flock.parse.ugensForDefs : flock.parse.ugenForDef)(e, t, n);
    }, flock.parse.ugenDef.mergeOptions = function(e) {
        var t = flock.ugenDefaults(e.ugen) || {};
        return (t = fluid.copy(t)).options = t.ugenOptions, delete t.ugenOptions, m.extend(!0, {}, t, e);
    }, flock.parse.ugensForDefs = function(e, t, n) {
        var o, r = [];
        for (o = 0; o < e.length; o++) r[o] = flock.parse.ugenForDef(e[o], t, n);
        return r;
    }, flock.parse.ugenForDef = function(e, t, n) {
        t = t || flock.environment;
        var o = n = m.extend(!0, {
            audioSettings: t.audioSystem.model,
            buses: t.busManager.buses,
            buffers: t.buffers
        }, n), r = o.visitors, a = o.audioSettings.rates;
        if (e = flock.parse.expandValueDef(e), flock.isIterable(e)) return flock.parse.ugensForDefs(e, t, n);
        e = flock.parse.expandInputs(e), flock.parse.expandRate(e, n);
        var i, l = (e = flock.parse.ugenDef.mergeOptions(e, n)).inputs, u = {};
        for (i in l) {
            var s = l[i];
            null !== s && (u[i] = flock.input.shouldExpand(i, e) ? flock.parse.ugenForDef(s, t, n) : s);
        }
        if (!e.ugen) throw new Error("Unit generator definition lacks a 'ugen' property; can't initialize the synth graph. Value: " + fluid.prettyPrintJSON(e));
        var f = flock.parse.makeUGen(e, u, t, n);
        if (e.id && (f.id = e.id), f.options.ugenDef = e, r) for (var c = 0; c < r.length; c++) r[c](f, e, a);
        return f;
    }, flock.parse.expandBufferDef = function(e) {
        return "string" == typeof e ? {
            id: e
        } : flock.isIterable(e) || e.data || e.format ? flock.bufferDesc(e) : e;
    }, flock.parse.bufferForDef = function(e, t, n) {
        (e = flock.parse.expandBufferDef(e)).data && e.data.channels ? (e = flock.bufferDesc(e), 
        flock.parse.bufferForDef.resolveBuffer(e, t, n)) : flock.parse.bufferForDef.resolveDef(e, t, n);
    }, flock.parse.bufferForDef.createBufferSource = function(e) {
        return flock.bufferSource({
            sampleRate: e.audioSystem.model.sampleRate
        });
    }, flock.parse.bufferForDef.findSource = function(e, t) {
        var n;
        return t && e.id ? (n = t.bufferSources[e.id]) || (n = flock.parse.bufferForDef.createBufferSource(t), 
        t.bufferSources[e.id] = n) : n = flock.parse.bufferForDef.createBufferSource(t), 
        n;
    }, flock.parse.bufferForDef.bindToPromise = function(e, t, n) {
        var o = function(e) {
            t.events.onBufferUpdated.addListener(o), n && n.setBuffer(e);
        };
        e.then(o, function(e) {
            throw !e && t.model.src && t.model.src.indexOf(".aif") && (e = "if this is an AIFF file, you might need to include flocking-audiofile-compatibility.js in some browsers."), 
            new Error("Error while resolving buffer " + t.model.src + ": " + e);
        });
    }, flock.parse.bufferForDef.resolveDef = function(e, t, n) {
        var o, r = flock.parse.bufferForDef.findSource(e, n);
        e.src = e.url || e.src, e.selector && "undefined" != typeof document && (e.src = document.querySelector(e.selector).files[0]), 
        o = r.get(e), flock.parse.bufferForDef.bindToPromise(o, r, t);
    }, flock.parse.bufferForDef.resolveBuffer = function(e, t, n) {
        var o = flock.parse.bufferForDef.findSource(e, n), r = o.set(e);
        flock.parse.bufferForDef.bindToPromise(r, o, t);
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var f = "undefined" != typeof window ? window.atob : require("atob");
    flock.applyDeferred = function(e, t, n) {
        e && (n = void 0 === n ? 0 : n, setTimeout(function() {
            e.apply(null, t);
        }, n));
    }, fluid.registerNamespace("flock.net"), flock.net.readBufferFromUrl = function(e) {
        var t = e.src, n = new XMLHttpRequest();
        n.onreadystatechange = function() {
            if (4 === n.readyState) if (flock.net.isXHRSuccessful(n)) e.success(n.response, flock.file.parseFileExtension(t)); else {
                if (!e.error) throw new Error(n.statusText);
                e.error(n.statusText);
            }
        }, n.open(e.method || "GET", t, !0), n.responseType = e.responseType || "arraybuffer", 
        n.send(e.data);
    }, flock.net.isXHRSuccessful = function(e) {
        return 200 === e.status || 0 === e.responseURL.indexOf("file://") && 0 === e.status && e.response;
    }, fluid.registerNamespace("flock.file"), flock.file.mimeTypes = {
        "audio/wav": "wav",
        "audio/x-wav": "wav",
        "audio/wave": "wav",
        "audio/x-aiff": "aiff",
        "audio/aiff": "aiff",
        "sound/aiff": "aiff"
    }, flock.file.typeAliases = {
        aif: "aiff",
        wave: "wav"
    }, flock.file.parseFileExtension = function(e) {
        var t, n = e.lastIndexOf(".");
        if (!(n < 0)) return t = (t = e.substring(n + 1)).toLowerCase(), flock.file.typeAliases[t] || t;
    }, flock.file.parseMIMEType = function(e) {
        return flock.file.mimeTypes[e];
    }, flock.file.stringToBuffer = function(e) {
        var t, n = e.length, o = new ArrayBuffer(n), r = new Uint8Array(o);
        for (t = 0; t < n; t++) r[t] = e.charCodeAt(t);
        return r.buffer;
    }, flock.file.readBufferFromDataUrl = function(t) {
        var e = t.src, n = e.indexOf(","), o = e.substring(0, n), r = e.substring(n + 1), a = o.indexOf(";base64"), i = -1 < a, l = e.indexOf("data:") + 5, u = i ? a : n, s = e.substring(l, u);
        i && (r = f(r)), flock.applyDeferred(function() {
            var e = flock.file.stringToBuffer(r);
            t.success(e, flock.file.parseMIMEType(s));
        });
    }, flock.file.readBufferFromFile = function(t) {
        var e = new FileReader();
        return e.onload = function(e) {
            t.success(e.target.result, flock.file.parseFileExtension(t.src.name));
        }, e.readAsArrayBuffer(t.src), e;
    }, fluid.registerNamespace("flock.audio"), flock.audio.loadBuffer = function(e) {
        var t = e.src || e.url;
        t && (t instanceof ArrayBuffer && flock.applyDeferred(e.success, [ t, e.type ]), 
        flock.audio.loadBuffer.readerForSource(t)(e));
    }, flock.audio.loadBuffer.readerForSource = function(e) {
        return "undefined" != typeof File && e instanceof File ? flock.file.readBufferFromFile : 0 === e.indexOf("data:") ? flock.file.readBufferFromDataUrl : flock.net.readBufferFromUrl;
    }, flock.audio.decode = function(r) {
        var a = r.success;
        r.success = function(e, t) {
            var n = flock.audio.decoderStrategies, o = n[t] || n.default;
            r.decoder && (o = "string" == typeof r.decoder ? fluid.getGlobalValue(r.decoder) : r.decoder), 
            o({
                rawData: e,
                type: t,
                success: a,
                error: r.error,
                sampleRate: r.sampleRate
            });
        }, flock.audio.loadBuffer(r);
    }, flock.audio.decode.webAudio = function(n) {
        flock.webAudio.audioSystem.audioContextSingleton.decodeAudioData(n.rawData, function(e) {
            var t = flock.bufferDesc.fromAudioBuffer(e);
            n.success(t);
        }, n.error);
    }, flock.audio.decoderStrategies = {
        default: flock.audio.decode.webAudio
    }, flock.audio.registerDecoderStrategy = function(e, t) {
        if (e) if ("object" != typeof e) "string" == typeof t && (t = fluid.getGlobalValue(t)), 
        flock.audio.decoderStrategies[e] = t; else for (var n in e) flock.audio.decoderStrategies[n] = e[n];
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var l = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
    for (var e in fluid.registerNamespace("flock.audio.convert"), flock.audio.convert.maxFloatValue = function(e) {
        return 1 - 1 / e.scale;
    }, flock.audio.convert.pcm = {
        int8: {
            scale: 128,
            setter: "setInt8",
            width: 1
        },
        int16: {
            scale: 32768,
            setter: "setInt16",
            width: 2
        },
        int32: {
            scale: 2147483648,
            setter: "setInt32",
            width: 4
        },
        float32: {
            scale: 1,
            setter: "setFloat32",
            width: 4
        }
    }, flock.audio.convert.pcm) {
        var t = flock.audio.convert.pcm[e];
        t.maxFloatValue = flock.audio.convert.maxFloatValue(t);
    }
    flock.audio.convert.specForPCMType = function(e) {
        var t = "string" == typeof e ? flock.audio.convert.pcm[e] : e;
        return t || flock.fail("Flocking does not support " + e + " format PCM wave files."), 
        t;
    }, flock.audio.convert.floatToInt = function(e, t) {
        var n = Math.min(t.maxFloatValue, e);
        return n = Math.max(-1, n), n *= t.scale, n = Math.round(n);
    }, flock.audio.convert.floatsToInts = function(e, t) {
        if (e) {
            for (var n = "Int" + 8 * t.width + "Array", o = new l[n](e.length), r = 0; r < e.length; r++) {
                var a = e[r], i = flock.audio.convert.floatToInt(a, t);
                o[r] = i;
            }
            return o;
        }
    }, flock.audio.convert.intToFloat = function(e, t) {
        return e / t.scale;
    }, flock.audio.convert.intsToFloats = function(e, t) {
        if (e) {
            for (var n = new Float32Array(e.length), o = 0; o < e.length; o++) {
                var r = e[o], a = flock.audio.convert.intToFloat(r, t);
                n[o] = a;
            }
            return n;
        }
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.registerNamespace("flock.audio.encode"), flock.audio.interleave = function(e) {
    var t, n, o = e.format.numSampleFrames, r = e.data.channels, a = e.format.numChannels, i = new Float32Array(o * a), l = 0;
    for (t = 0; t < o; t++) for (n = 0; n < a; n++) i[l] = r[n][t], l++;
    return i;
}, flock.audio.encode = function(e, t, n) {
    return "wav" !== (t = t || "wav").toLowerCase() && flock.fail("Flocking currently only supports encoding WAVE files."), 
    flock.audio.encode.wav(e, n);
}, flock.audio.encode.writeFloat32Array = function(e, t, n) {
    for (var o = 0; o < n.length; o++) t.setFloat32(e, n[o], !0), e += 4;
    return t;
}, flock.audio.encode.setString = function(e, t, n) {
    for (var o = 0; o < n.length; o++) e.setUint8(t + o, n.charCodeAt(o));
}, flock.audio.encode.setBytes = function(e, t, n) {
    for (var o = 0; o < n.length; o++) e.setUint8(t + o, n[o]);
}, flock.audio.encode.writeAsPCM = function(e, t, n, o) {
    if ("setFloat32" === e.setter && o instanceof Float32Array) return flock.audio.encode.writeFloat32Array(t, n, o);
    for (var r = 0; r < o.length; r++) {
        var a = flock.audio.convert.floatToInt(o[r], e);
        n[e.setter](t, a, !0), t += e.width;
    }
    return n;
}, flock.audio.encode.wav = function(e, t) {
    t = t || flock.audio.convert.pcm.int16;
    var n = flock.audio.convert.specForPCMType(t), o = flock.audio.interleave(e), r = e.format.numChannels, a = e.format.sampleRate, i = "setFloat32" !== n.setter, l = 16, u = 1, s = o.length * n.width, f = 8 + s, c = n.width * r, d = 8 * n.width;
    (2 < r || !i) && (l += 12, 2 < r ? (l += 24, u = 65534) : (l += 2, u = 3));
    var m = 12 + l + f, h = new ArrayBuffer(8 + m), p = new DataView(h);
    flock.audio.encode.setString(p, 0, "RIFF"), p.setUint32(4, m, !0), flock.audio.encode.setString(p, 8, "WAVE"), 
    flock.audio.encode.setString(p, 12, "fmt "), p.setUint32(16, l, !0), p.setUint16(20, u, !0), 
    p.setUint16(22, r, !0), p.setUint32(24, a, !0), p.setUint32(28, a * c, !0), p.setUint16(32, c, !0), 
    p.setUint16(34, d, !0);
    var k = 36;
    return 3 === u ? (p.setUint16(k, 0, !0), k += 2, k = flock.audio.encode.wav.writeFactChunk(p, k, e.format.numSampleFrames)) : 65534 === u && (p.setUint16(k, 22, !0), 
    k += 2, k = flock.audio.encode.wav.additionalFormat(k, p, d, i), k = flock.audio.encode.wav.writeFactChunk(p, k, e.format.numSampleFrames)), 
    flock.audio.encode.wav.writeDataChunk(n, k, p, o, s), p.buffer;
}, flock.audio.encode.wav.subformats = {
    pcm: new Uint8Array([ 1, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ]),
    float: new Uint8Array([ 3, 0, 0, 0, 0, 0, 16, 0, 128, 0, 0, 170, 0, 56, 155, 113 ])
}, flock.audio.encode.wav.additionalFormat = function(e, t, n, o) {
    t.setUint16(e, n, !0), e += 2, t.setUint32(e, 2147483648, !0), e += 4;
    var r = flock.audio.encode.wav.subformats[o ? "pcm" : "float"];
    return flock.audio.encode.setBytes(t, e, r), e += 16;
}, flock.audio.encode.wav.writeFactChunk = function(e, t, n) {
    return flock.audio.encode.setString(e, t, "fact"), t += 4, e.setUint32(t, 4, !0), 
    t += 4, e.setUint32(t, n, !0), t += 4;
}, flock.audio.encode.wav.writeDataChunk = function(e, t, n, o, r) {
    flock.audio.encode.setString(n, t, "data"), t += 4, n.setUint32(t, r, !0), t += 4, 
    flock.audio.encode.writeAsPCM(e, t, n, o);
};

fluid = fluid || require("infusion");

(flock = fluid.registerNamespace("flock")).shim = {
    URL: "undefined" != typeof window ? window.URL || window.webkitURL || window.msURL : void 0
}, flock.worker = function(e) {
    var t, n, o = typeof e;
    if ("function" === o) e = "(" + e.toString() + ")();"; else if ("string" !== o) throw new Error("A flock.worker must be initialized with a String or a Function.");
    return window.Blob ? (n = new Blob([ e ], {
        type: "text/javascript"
    }), t = flock.shim.URL.createObjectURL(n)) : t = "data:text/javascript;base64," + window.btoa(e), 
    new Worker(t);
}, fluid.registerNamespace("flock.scheduler"), fluid.defaults("flock.scheduler.clock", {
    gradeNames: [ "fluid.component" ],
    invokers: {
        end: "fluid.mustBeOverridden"
    },
    events: {
        tick: null
    },
    listeners: {
        "onDestroy.end": "{that}.end()"
    }
}), fluid.defaults("flock.scheduler.intervalClock", {
    gradeNames: [ "flock.scheduler.clock" ],
    members: {
        scheduled: {}
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.intervalClock.schedule",
            args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.tick.fire", "{that}.events.onClear.fire" ]
        },
        clear: {
            funcName: "flock.scheduler.intervalClock.clear",
            args: [ "{arguments}.0", "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        clearAll: {
            funcName: "flock.scheduler.intervalClock.clearAll",
            args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        end: "{that}.clearAll"
    }
}), flock.scheduler.intervalClock.schedule = function(e, t, n) {
    var o = setInterval(function() {
        n(e);
    }, e);
    t[e] = o;
}, flock.scheduler.intervalClock.clear = function(e, t) {
    var n = t[e];
    clearInterval(n), delete t[e];
}, flock.scheduler.intervalClock.clearAll = function(e, t) {
    for (var n in e) flock.scheduler.intervalClock.clear(n, e, t);
}, fluid.defaults("flock.scheduler.scheduleClock", {
    gradeNames: [ "flock.scheduler.clock" ],
    members: {
        scheduled: []
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.scheduleClock.schedule",
            args: [ "{arguments}.0", "{that}.scheduled", "{that}.events" ]
        },
        clear: {
            funcName: "flock.scheduler.scheduleClock.clear",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        clearAll: {
            funcName: "flock.scheduler.scheduleClock.clearAll",
            args: [ "{that}.scheduled", "{that}.events.onClear.fire" ]
        },
        end: "{that}.clearAll"
    }
}), flock.scheduler.scheduleClock.schedule = function(e, t, n) {
    var o;
    o = setTimeout(function() {
        clearTimeout(o), n.tick.fire(e);
    }, e), t.push(o);
}, flock.scheduler.scheduleClock.clear = function(e, t, n) {
    -1 < (t = void 0 === t ? n.indexOf(e) : t) && (n.splice(t, 1), clearTimeout(e));
}, flock.scheduler.scheduleClock.clearAll = function(e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        clearTimeout(n);
    }
    e.length = 0;
}, fluid.defaults("flock.scheduler.webWorkerClock", {
    gradeNames: [ "fluid.component" ],
    members: {
        worker: {
            expander: {
                funcName: "flock.worker",
                args: "@expand:fluid.getGlobalValue(flock.scheduler.webWorkerClock.workerImpl)"
            }
        }
    },
    invokers: {
        postToWorker: {
            funcName: "flock.scheduler.webWorkerClock.postToWorker",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.options.messages", "{that}.worker" ]
        },
        schedule: "{that}.postToWorker(schedule, {arguments}.0)",
        clear: "{that}.postToWorker(clear, {arguments}.0)",
        clearAll: "{that}.postToWorker(clearAll)",
        end: "{that}.postToWorker(end)"
    },
    events: {
        tick: null
    },
    listeners: {
        onCreate: {
            funcName: "flock.scheduler.webWorkerClock.init",
            args: [ "{that}" ]
        },
        "onDestroy.clearAllScheduled": "{that}.clearAll",
        "onDestroy.endWorker": {
            priority: "after:clearAllScheduled",
            func: "{that}.end"
        }
    },
    startMsg: {
        msg: "start",
        value: "{that}.options.clockType"
    },
    messages: {
        schedule: {
            msg: "schedule"
        },
        clear: {
            msg: "clear"
        },
        clearAll: {
            msg: "clearAll"
        },
        end: {
            msg: "end"
        }
    }
}), flock.scheduler.webWorkerClock.init = function(t) {
    t.worker.addEventListener("message", function(e) {
        t.events.tick.fire(e.data.value);
    }, !1), t.worker.postMessage(t.options.startMsg);
}, flock.scheduler.webWorkerClock.postToWorker = function(e, t, n, o) {
    var r = n[e];
    void 0 !== t && (r.value = t), o.postMessage(r);
}, flock.scheduler.webWorkerClock.workerImpl = function() {
    var t = t || {};
    t.worker = t.worker || {}, t.worker.clock = function() {
        var e = {
            tick: function(e) {
                self.postMessage({
                    msg: "tick",
                    value: e
                });
            }
        };
        return e;
    }, t.worker.intervalClock = function() {
        var n = t.worker.clock();
        return n.scheduled = {}, n.schedule = function(e) {
            var t = setInterval(function() {
                n.tick(e);
            }, e);
            n.scheduled[e] = t;
        }, n.clear = function(e) {
            var t = n.scheduled[e];
            clearInterval(t), delete n.scheduled[e];
        }, n.clearAll = function() {
            for (var e in n.scheduled) n.clear(e);
        }, n;
    }, t.worker.scheduleClock = function() {
        var n = t.worker.clock();
        return n.scheduled = [], n.schedule = function(e) {
            var t;
            t = setTimeout(function() {
                n.clear(t), n.tick(e);
            }, e), n.scheduled.push(t);
        }, n.clear = function(e, t) {
            -1 < (t = void 0 === t ? n.scheduled.indexOf(e) : t) && n.scheduled.splice(t, 1), 
            clearTimeout(e);
        }, n.clearAll = function() {
            for (var e = 0; e < n.scheduled.length; e++) {
                var t = n.scheduled[e];
                clearTimeout(t);
            }
            n.scheduled.length = 0;
        }, n;
    }, self.addEventListener("message", function(e) {
        "start" === e.data.msg ? t.clock = t.worker[e.data.value]() : "end" === e.data.msg ? t.clock && (t.clock.clearAll(), 
        self.close()) : t.clock && t.clock[e.data.msg](e.data.value);
    }, !1);
}, fluid.defaults("flock.scheduler.webWorkerIntervalClock", {
    gradeNames: [ "flock.scheduler.webWorkerClock" ],
    clockType: "intervalClock"
}), fluid.defaults("flock.scheduler.webWorkerScheduleClock", {
    gradeNames: [ "flock.scheduler.webWorkerClock" ],
    clockType: "scheduleClock"
}), fluid.defaults("flock.scheduler", {
    gradeNames: [ "fluid.component" ],
    events: {
        onScheduled: null,
        onFinished: null,
        onClearAll: null
    },
    listeners: {
        "onClearAll.clearClock": [ "{that}.clock.clearAll()" ]
    }
}), flock.scheduler.addListener = function(e, t, n) {
    return t.push(e), n(e), e;
}, flock.scheduler.removeListener = function(e, t, n) {
    if (e) {
        var o = t.indexOf(e);
        -1 < o ? (t.splice(o, 1), n(e)) : e.wrappedListener && flock.scheduler.removeListener(e.wrappedListener, t, n);
    }
}, fluid.defaults("flock.scheduler.repeat", {
    gradeNames: [ "flock.scheduler" ],
    members: {
        listeners: {}
    },
    components: {
        clock: {
            type: "flock.scheduler.webWorkerIntervalClock"
        }
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.repeat.schedule",
            args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.listeners", "{that}.events.onScheduled.fire" ]
        },
        clear: "{that}.events.onFinished.fire",
        clearAll: {
            funcName: "flock.scheduler.repeat.clearAll",
            args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
        },
        clearInterval: {
            funcName: "flock.scheduler.repeat.clearInterval",
            args: [ "{arguments}.0", "{that}.listeners", "{that}.events.onFinished.fire" ]
        },
        addIntervalListener: {
            funcName: "flock.scheduler.repeat.addIntervalListener",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
        },
        removeIntervalListener: {
            funcName: "flock.scheduler.repeat.removeIntervalListener",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
        }
    },
    listeners: {
        onScheduled: [ "{that}.addIntervalListener({arguments}.0, {arguments}.1)", "{that}.clock.schedule({arguments}.0)" ],
        onFinished: [ "{that}.removeIntervalListener({arguments}.0, {arguments}.1)" ]
    }
}), flock.scheduler.repeat.intervalListeners = function(e, t) {
    return t[e];
}, flock.scheduler.repeat.addIntervalListener = function(e, t, n, o) {
    var r = flock.scheduler.repeat.intervalListeners(e, n);
    flock.scheduler.addListener(t, r, o);
}, flock.scheduler.repeat.removeIntervalListener = function(e, t, n, o) {
    var r = flock.scheduler.repeat.intervalListeners(e, n);
    flock.scheduler.removeListener(t, r, o);
}, flock.scheduler.repeat.schedule = function(e, t, n, o, r, a) {
    e = n.value(e), t = flock.scheduler.async.prepareListener(t, o);
    var i = flock.scheduler.repeat.wrapValueListener(e, t);
    return flock.scheduler.repeat.addInterval(e, r), a(e, i), i;
}, flock.scheduler.repeat.wrapValueListener = function(t, n) {
    var e = function(e) {
        e === t && n(e);
    };
    return e.wrappedListener = n, e;
}, flock.scheduler.repeat.addInterval = function(e, t) {
    var n = t[e];
    n || (n = t[e] = []);
}, flock.scheduler.repeat.clearAll = function(e, t, n) {
    for (var o in e) flock.scheduler.repeat.clearInterval(o, e, t);
    n();
}, flock.scheduler.repeat.clearInterval = function(e, t, n) {
    var o = t[e];
    if (o) for (var r = 0; r < o.length; r++) n(e, o[r]);
}, fluid.defaults("flock.scheduler.once", {
    gradeNames: [ "flock.scheduler" ],
    members: {
        listeners: []
    },
    components: {
        clock: {
            type: "flock.scheduler.webWorkerScheduleClock"
        }
    },
    invokers: {
        schedule: {
            funcName: "flock.scheduler.once.schedule",
            args: [ "{arguments}.0", "{arguments}.1", "{timeConverter}", "{synthContext}", "{that}.clear", "{that}.events.onScheduled.fire" ]
        },
        clear: "{that}.events.onFinished.fire",
        clearAll: {
            funcName: "flock.scheduler.once.clearAll",
            args: [ "{that}.listeners", "{that}.events.onFinished.fire", "{that}.events.onClearAll.fire" ]
        }
    },
    listeners: {
        onScheduled: [ {
            funcName: "flock.scheduler.addListener",
            args: [ "{arguments}.1", "{that}.listeners", "{that}.clock.events.tick.addListener" ]
        }, {
            func: "{that}.clock.schedule",
            args: [ "{arguments}.0" ]
        } ],
        onFinished: {
            funcName: "flock.scheduler.removeListener",
            args: [ "{arguments}.0", "{that}.listeners", "{that}.clock.events.tick.removeListener" ]
        }
    }
}), flock.scheduler.once.wrapValueListener = function(t, n, o) {
    var r = function(e) {
        e === t && (n(e), o(r));
    };
    return r.wrappedListener = n, r;
}, flock.scheduler.once.schedule = function(e, t, n, o, r, a) {
    e = n.value(e), t = flock.scheduler.async.prepareListener(t, o);
    var i = flock.scheduler.once.wrapValueListener(e, t, r);
    return a(e, i), i;
}, flock.scheduler.once.clearAll = function(e, t, n) {
    for (var o = 0; o < e.length; o++) t(e[o]);
    n();
}, fluid.defaults("flock.scheduler.async", {
    gradeNames: [ "fluid.component" ],
    subSchedulerOptions: {
        components: {
            timeConverter: "{async}.timeConverter"
        },
        listeners: {
            "{async}.events.onClear": "{that}.clear()",
            "{async}.events.onClearAll": "{that}.clearAll()",
            "{async}.events.onEnd": "{that}.clock.end()"
        }
    },
    distributeOptions: {
        source: "{that}.options.subSchedulerOptions",
        removeSource: !0,
        target: "{that flock.scheduler}.options"
    },
    components: {
        timeConverter: {
            type: "flock.convert.seconds"
        },
        onceScheduler: {
            type: "flock.scheduler.once"
        },
        repeatScheduler: {
            type: "flock.scheduler.repeat"
        },
        synthContext: void 0
    },
    invokers: {
        repeat: {
            func: "{repeatScheduler}.schedule",
            args: [ "{arguments}.0", "{arguments}.1" ]
        },
        once: {
            func: "{onceScheduler}.schedule",
            args: [ "{arguments}.0", "{arguments}.1" ]
        },
        sequence: {
            funcName: "flock.scheduler.async.sequence",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.once" ]
        },
        schedule: {
            funcName: "flock.scheduler.async.schedule",
            args: [ "{arguments}.0", "{that}" ]
        },
        clear: "{that}.events.onClear.fire",
        clearAll: "{that}.events.onClearAll.fire",
        end: "{that}.events.onEnd.fire"
    },
    events: {
        onClear: null,
        onClearAll: null,
        onEnd: null
    },
    listeners: {
        onCreate: "{that}.schedule({that}.options.score)",
        onEnd: "{that}.clearAll"
    }
}), flock.scheduler.async.sequence = function(e, t, n) {
    for (var o = [], r = 0; r < e.length; r++) {
        var a = n(e[r], t);
        o.push(a);
    }
    return o;
}, flock.scheduler.async.schedule = function(e, t) {
    if (e) {
        e = flock.isIterable(e) ? e : [ e ];
        for (var n = 0; n < e.length; n++) {
            var o = e[n];
            flock.invoke(t, o.interval, [ o.time, o.change ]);
        }
    }
}, flock.scheduler.async.prepareListener = function(e, t) {
    return "function" == typeof e ? e : flock.scheduler.async.evaluateChangeSpec(e, t);
}, flock.scheduler.async.getTargetSynth = function(e, t) {
    var n = e.synth;
    return n ? "string" != typeof n ? n : fluid.get(t, n) : t;
}, flock.scheduler.async.makeSynthUpdater = function(o, r, a, i) {
    return function() {
        for (var e in o) {
            var t = o[e];
            a[e] = flock.evaluate.synthValue(t);
        }
        var n = flock.scheduler.async.getTargetSynth(r, i);
        n ? n.set(a) : flock.fail("A target synth named " + r.synth + " could not be found in the specified synthContext. Synth context was: " + i);
    };
}, flock.scheduler.async.evaluateChangeSpec = function(e, t) {
    var n = {}, o = {};
    for (var r in e.values) {
        var a = e.values[r];
        a.synthDef ? n[r] = flock.synth.value(a) : o[r] = a;
    }
    return flock.scheduler.async.makeSynthUpdater(n, e, o, t);
}, fluid.defaults("flock.scheduler.async.tempo", {
    gradeNames: [ "flock.scheduler.async" ],
    bpm: 60,
    components: {
        timeConverter: {
            type: "flock.convert.beats",
            options: {
                bpm: "{tempo}.options.bpm"
            }
        }
    }
}), fluid.registerNamespace("flock.convert"), fluid.defaults("flock.convert.ms", {
    gradeNames: [ "fluid.component" ],
    invokers: {
        value: "fluid.identity({arguments}.0)"
    }
}), fluid.defaults("flock.convert.seconds", {
    gradeNames: [ "fluid.component" ],
    invokers: {
        value: "flock.convert.seconds.toMillis({arguments}.0)"
    }
}), flock.convert.seconds.toMillis = function(e) {
    return 1e3 * e;
}, fluid.defaults("flock.convert.beats", {
    gradeNames: [ "fluid.component" ],
    bpm: 60,
    invokers: {
        value: "flock.convert.beats.toMillis({arguments}.0, {that}.options.bpm)"
    }
}), flock.convert.beats.toMillis = function(e, t) {
    return t <= 0 ? 0 : e / t * 6e4;
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.registerNamespace("flock.webAudio"), flock.webAudio.createNode = function(e, t) {
    var n = t.args ? fluid.makeArray(t.args) : void 0, o = "create" + t.node, r = o.indexOf("Node");
    -1 < r && (o = o.substring(0, r));
    var a = e[o].apply(e, n);
    return flock.webAudio.initNodeParams(e, a, t), flock.webAudio.initNodeProperties(a, t), 
    flock.webAudio.initNodeInputs(a, t), a;
}, flock.webAudio.setAudioParamValue = function(e, t, n, o) {
    o = o || 0;
    var r = e.currentTime + o;
    t.setValueAtTime(n, r);
}, flock.webAudio.initNodeParams = function(e, t, n) {
    var o = n.params;
    if (t && o) {
        for (var r in o) {
            var a = t[r], i = o[r];
            flock.webAudio.setAudioParamValue(e, a, i);
        }
        return t;
    }
}, flock.webAudio.safariPropertyProhibitions = [ "channelCount", "channelCountMode" ], 
flock.webAudio.shouldSetProperty = function(e) {
    return !flock.platform.browser.safari || flock.webAudio.safariPropertyProhibitions.indexOf(e) < 0;
}, flock.webAudio.initNodeProperties = function(e, t) {
    var n = t.props;
    if (n) {
        for (var o in n) {
            var r = n[o];
            flock.webAudio.shouldSetProperty(o) && (e[o] = r);
        }
        return e;
    }
}, flock.webAudio.connectInput = function(e, t, n, o) {
    n.connect(e, o, t);
}, flock.webAudio.initNodeInputs = function(e, t) {
    var n = t.inputs;
    for (var o in n) {
        var r = n[o], a = parseInt(o, 10);
        r = fluid.makeArray(r);
        for (var i = 0; i < r.length; i++) {
            var l = r[i];
            flock.webAudio.connectInput(e, a, l);
        }
    }
}, fluid.defaults("flock.webAudio.node", {
    gradeNames: [ "fluid.modelComponent" ],
    members: {
        node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
    },
    nodeSpec: {
        args: [],
        params: {},
        properties: {}
    }
}), fluid.defaults("flock.webAudio.gain", {
    gradeNames: [ "flock.webAudio.node" ],
    members: {
        node: "@expand:flock.webAudio.createNode({audioSystem}.context, {that}.options.nodeSpec)"
    },
    nodeSpec: {
        node: "Gain"
    }
}), fluid.defaults("flock.webAudio.scriptProcessor", {
    gradeNames: [ "flock.webAudio.node" ],
    nodeSpec: {
        node: "ScriptProcessor",
        args: [ "{audioSystem}.model.bufferSize", "{audioSystem}.model.numInputBuses", "{audioSystem}.model.chans" ],
        params: {},
        properties: {
            channelCountMode: "explicit"
        }
    }
}), fluid.defaults("flock.webAudio.channelMerger", {
    gradeNames: [ "flock.webAudio.node" ],
    nodeSpec: {
        node: "ChannelMerger",
        args: [ "{audioSystem}.model.numInputBuses" ],
        properties: {
            channelCountMode: "discrete"
        }
    }
}), fluid.defaults("flock.webAudio.outputFader", {
    gradeNames: [ "fluid.component" ],
    fadeDuration: .5,
    gainSpec: {
        node: "Gain",
        params: {
            gain: 0
        },
        properties: {
            channelCount: "{flock.enviro}.audioSystem.model.chans",
            channelCountMode: "explicit"
        }
    },
    members: {
        gainNode: "@expand:flock.webAudio.outputFader.createGainNode({flock.enviro}.audioSystem.nativeNodeManager, {that}.options.gainSpec)",
        context: "{flock.enviro}.audioSystem.context"
    },
    invokers: {
        fadeIn: {
            funcName: "flock.webAudio.outputFader.fadeIn",
            args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
        },
        fadeTo: {
            funcName: "flock.webAudio.outputFader.fadeTo",
            args: [ "{that}.context", "{that}.gainNode", "{arguments}.0", "{that}.options.fadeDuration" ]
        }
    }
}), flock.webAudio.outputFader.createGainNode = function(e, t) {
    return e.createOutputNode(t);
}, flock.webAudio.outputFader.fade = function(e, t, n, o, r) {
    r = r || 0;
    var a = e.currentTime + r;
    flock.webAudio.setAudioParamValue(e, t.gain, n), t.gain.linearRampToValueAtTime(o, a);
}, flock.webAudio.outputFader.fadeTo = function(e, t, n, o) {
    flock.webAudio.outputFader.fade(e, t, t.gain.value, n, o);
}, flock.webAudio.outputFader.fadeIn = function(e, t, n, o) {
    flock.webAudio.outputFader.fade(e, t, 0, n, o);
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.audioSystem", {
    gradeNames: [ "flock.audioSystem" ],
    channelRange: {
        min: "@expand:flock.webAudio.audioSystem.calcMinChannels()",
        max: "@expand:flock.webAudio.audioSystem.calcMaxChannels({that}.context.destination)"
    },
    members: {
        context: "@expand:flock.webAudio.audioSystem.createContext()"
    },
    model: {
        rates: {
            audio: "{that}.context.sampleRate"
        }
    },
    components: {
        outputManager: {
            type: "flock.webAudio.outputManager"
        },
        nativeNodeManager: {
            type: "flock.webAudio.nativeNodeManager"
        },
        inputDeviceManager: {
            type: "flock.webAudio.inputDeviceManager"
        },
        bufferWriter: {
            type: "flock.webAudio.bufferWriter"
        }
    },
    listeners: {
        onCreate: [ "flock.webAudio.audioSystem.configureDestination({that}.context, {that}.model.chans)" ]
    }
}), flock.webAudio.audioSystem.createContext = function() {
    var e = flock.webAudio.audioSystem;
    return e.audioContextSingleton || (e.audioContextSingleton = new flock.shim.AudioContext()), 
    e.audioContextSingleton;
}, flock.webAudio.audioSystem.calcMaxChannels = function(e) {
    return flock.platform.browser.safari ? e.channelCount : e.maxChannelCount;
}, flock.webAudio.audioSystem.calcMinChannels = function() {
    return flock.platform.browser.safari ? 2 : 1;
}, flock.webAudio.audioSystem.configureDestination = function(e, t) {
    flock.platform.browser.safari || (e.destination.channelCount = t, e.destination.channelCountMode = "explicit", 
    e.destination.channelInterpretation = "discrete");
}, fluid.defaults("flock.webAudio.enviroContextDistributor", {
    gradeNames: [ "fluid.component" ],
    distributeOptions: [ {
        target: "{/ flock.enviro > audioSystem}.options",
        record: {
            gradeNames: "flock.webAudio.audioSystem"
        }
    } ]
}), fluid.constructSingle([], {
    singleRootType: "flock.enviroContextDistributor",
    type: "flock.webAudio.enviroContextDistributor"
});

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.bufferWriter", {
    gradeNames: "fluid.component",
    invokers: {
        save: "flock.webAudio.bufferWriter.saveBuffer({arguments}.0)"
    }
}), flock.webAudio.bufferWriter.saveBuffer = function(t) {
    try {
        var e = flock.audio.encode.wav(t.buffer, t.format), n = new Blob([ e ], {
            type: "audio/wav"
        });
        return flock.webAudio.bufferWriter.download(t.path, n), t.success && t.success(e), 
        e;
    } catch (e) {
        t.error ? t.error(e) : flock.fail("There was an error while trying to download the buffer named " + t.buffer.id + ". Error: " + e);
    }
}, flock.webAudio.bufferWriter.download = function(e, t) {
    var n = flock.shim.URL.createObjectURL(t), o = window.document.createElement("a"), r = document.createEvent("Event");
    o.href = n, o.download = e, r.initEvent("click", !0, !0), o.dispatchEvent(r);
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    fluid.registerNamespace("flock.webAudio.chrome"), flock.webAudio.chrome.getSources = function(n) {
        return MediaStreamTrack.getSources(function(e) {
            var t = fluid.transform(e, function(e) {
                return e.deviceId = e.id, e;
            });
            n(t);
        });
    }, flock.webAudio.mediaStreamFailure = function(e) {
        var t = "This browser does not support getUserMedia() or the Media Streams API.";
        e ? e(new Error(t)) : fluid.log(fluid.logLevel.IMPORTANT, t);
    };
    var e = {
        AudioContext: window.AudioContext || window.webkitAudioContext,
        getUserMedia: function(e, t, n) {
            navigator.mediaDevices ? navigator.mediaDevices.getUserMedia(e).then(t).catch(n) : navigator.getUserMedia ? navigator.getUserMedia(e, t, n) : flock.webAudio.mediaStreamFailure(n);
        },
        getMediaDevicesImpl: navigator.getMediaDevices ? navigator.getMediaDevices : void 0 !== window.MediaStreamTrack ? flock.webAudio.chrome.getSources : flock.webAudio.mediaStreamFailure,
        getMediaDevice: function() {
            flock.shim.getMediaDevicesImpl.apply(navigator, arguments);
        }
    };
    jQuery.extend(flock.shim, e), fluid.defaults("flock.webAudio.inputDeviceManager", {
        gradeNames: [ "fluid.component" ],
        invokers: {
            openAudioDevice: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDevice",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId", "{that}.openFirstAudioDeviceWithLabel", "{that}.openAudioDeviceWithConstraints" ]
            },
            openAudioDeviceWithConstraints: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints",
                args: [ "{audioSystem}.context", "{enviro}", "{nativeNodeManager}.createMediaStreamInput", "{arguments}.0" ]
            },
            openAudioDeviceWithId: {
                funcName: "flock.webAudio.inputDeviceManager.openAudioDeviceWithId",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithConstraints" ]
            },
            openFirstAudioDeviceWithLabel: {
                funcName: "flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel",
                args: [ "{arguments}.0", "{that}.openAudioDeviceWithId" ]
            }
        }
    }), flock.webAudio.inputDeviceManager.openAudioDevice = function(e, t, n, o) {
        if (e) {
            if (e.id) return t(e.id);
            if (e.label) return n(e.label);
        }
        return o();
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithId = function(e, t) {
        t({
            audio: {
                optional: [ {
                    sourceId: e
                } ]
            }
        });
    }, flock.webAudio.inputDeviceManager.openFirstAudioDeviceWithLabel = function(n, o) {
        n && flock.shim.getMediaDevices(function(e) {
            var t = e.filter(function(e) {
                if (e.label.toLowerCase() === n.toLowerCase()) return !0;
            });
            0 < t.length ? o(t[0].deviceId) : fluid.log(fluid.logLevel.IMPORTANT, "An audio device named '" + n + "' could not be found.");
        });
    }, flock.webAudio.inputDeviceManager.openAudioDeviceWithConstraints = function(e, t, n, o) {
        o = o || {
            audio: !0
        };
        var r = t.busManager.acquireNextBus("input");
        return flock.shim.getUserMedia(o, function(e) {
            n(e, r);
        }, function(e) {
            fluid.log(fluid.logLevel.IMPORTANT, "An error occurred while trying to access the user's microphone. " + e);
        }), r;
    };
}();

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.registerNamespace("flock.midi"), flock.midi.requestAccess = function(e, t, n) {
    if (!navigator.requestMIDIAccess) {
        var o = "The Web MIDI API is not available. You may need to enable it in your browser's settings.";
        return fluid.log(fluid.logLevel.WARN, o), void n(o);
    }
    navigator.requestMIDIAccess({
        sysex: e
    }).then(t, n);
}, flock.midi.getPorts = function(e) {
    var t = {};
    return flock.midi.collectPorts("inputs", e, t), flock.midi.collectPorts("outputs", e, t), 
    t;
}, flock.midi.requestPorts = function(n, e) {
    flock.midi.requestAccess(!1, function(e) {
        var t = flock.midi.getPorts(e);
        n(t);
    }, e);
}, flock.midi.createPortViews = function(e) {
    return fluid.transform(e, function(e) {
        return {
            id: e.id,
            name: e.name,
            manufacturer: e.manufacturer,
            state: e.state,
            connection: e.connection
        };
    });
}, flock.midi.prettyPrintPorts = function(e) {
    return fluid.prettyPrintJSON({
        inputs: flock.midi.createPortViews(e.inputs),
        outputs: flock.midi.createPortViews(e.outputs)
    });
}, flock.midi.logPorts = function() {
    flock.midi.requestPorts(function(e) {
        var t = flock.midi.prettyPrintPorts(e);
        console.log(t);
    }, function(e) {
        console.log(e);
    });
}, flock.midi.collectPorts = function(e, t, n) {
    for (var o = n[e] = n[e] || [], r = t[e].values(), a = r.next(); !a.done; ) o.push(a.value), 
    a = r.next();
    return n;
}, flock.midi.read = function(e) {
    var t, n = e[0], o = 15 & n;
    switch (n >> 4) {
      case 8:
        t = flock.midi.read.noteOff;
        break;

      case 9:
        t = 0 < e[2] ? flock.midi.read.noteOn : flock.midi.read.noteOff;
        break;

      case 10:
        t = flock.midi.read.polyAftertouch;
        break;

      case 11:
        t = flock.midi.read.controlChange;
        break;

      case 12:
        t = flock.midi.read.programChange;
        break;

      case 13:
        t = flock.midi.read.channelAftertouch;
        break;

      case 14:
        t = flock.midi.read.pitchbend;
        break;

      case 15:
        t = flock.midi.read.system;
        break;

      default:
        return flock.fail("Received an unrecognized MIDI message: " + fluid.prettyPrintJSON(e));
    }
    return t(o, e);
}, flock.midi.read.note = function(e, t, n) {
    return {
        type: e,
        channel: t,
        note: n[1],
        velocity: n[2]
    };
}, flock.midi.read.noteOn = function(e, t) {
    return flock.midi.read.note("noteOn", e, t);
}, flock.midi.read.noteOff = function(e, t) {
    return flock.midi.read.note("noteOff", e, t);
}, flock.midi.read.polyAftertouch = function(e, t) {
    return {
        type: "aftertouch",
        channel: e,
        note: t[1],
        pressure: t[2]
    };
}, flock.midi.read.controlChange = function(e, t) {
    return {
        type: "control",
        channel: e,
        number: t[1],
        value: t[2]
    };
}, flock.midi.read.programChange = function(e, t) {
    return {
        type: "program",
        channel: e,
        program: t[1]
    };
}, flock.midi.read.channelAftertouch = function(e, t) {
    return {
        type: "aftertouch",
        channel: e,
        pressure: t[1]
    };
}, flock.midi.read.twoByteValue = function(e) {
    return e[2] << 7 | e[1];
}, flock.midi.read.pitchbend = function(e, t) {
    return {
        type: "pitchbend",
        channel: e,
        value: flock.midi.read.twoByteValue(t)
    };
}, flock.midi.read.system = function(e, t) {
    if (1 === e) return flock.midi.messageFailure("quarter frame MTC");
    var n;
    switch (e) {
      case 0:
        n = flock.midi.read.sysex;
        break;

      case 2:
        n = flock.midi.read.songPointer;
        break;

      case 3:
        n = flock.midi.read.songSelect;
        break;

      case 6:
        n = flock.midi.read.tuneRequest;
        break;

      case 8:
        n = flock.midi.read.clock;
        break;

      case 10:
        n = flock.midi.read.start;
        break;

      case 11:
        n = flock.midi.read.continue;
        break;

      case 12:
        n = flock.midi.read.stop;
        break;

      case 14:
        n = flock.midi.read.activeSense;
        break;

      case 15:
        n = flock.midi.read.reset;
        break;

      default:
        return flock.fail("Received an unrecognized MIDI system message: " + fluid.prettyPrintJSON(t));
    }
    return n(t);
}, flock.midi.messageFailure = function(e) {
    flock.fail("Flocking does not currently support MIDI " + e + " messages.");
}, flock.midi.read.sysex = function(e) {
    var t = 240 === e[0] ? 1 : 0, n = e.length - (247 === e[e.length - 1] ? 1 : 0);
    return {
        type: "sysex",
        data: e instanceof Uint8Array ? e.subarray(t, n) : e.slice(t, n)
    };
}, flock.midi.read.valueMessage = function(e, t) {
    return {
        type: e,
        value: t
    };
}, flock.midi.read.songPointer = function(e) {
    var t = flock.midi.read.twoByteValue(e);
    return flock.midi.read.valueMessage("songPointer", t);
}, flock.midi.read.songSelect = function(e) {
    return flock.midi.read.valueMessage("songSelect", e[1]);
}, flock.midi.read.tuneRequest = function() {
    return {
        type: "tuneRequest"
    };
}, flock.midi.systemRealtimeMessages = [ "tuneRequest", "clock", "start", "continue", "stop", "activeSense", "reset" ], 
flock.midi.createSystemRealtimeMessageReaders = function(e) {
    fluid.each(e, function(e) {
        flock.midi.read[e] = function() {
            return {
                type: e
            };
        };
    });
}, flock.midi.createSystemRealtimeMessageReaders(flock.midi.systemRealtimeMessages), 
fluid.defaults("flock.midi.system", {
    gradeNames: [ "fluid.component" ],
    sysex: !1,
    members: {
        access: void 0,
        ports: void 0
    },
    invokers: {
        requestAccess: {
            funcName: "flock.midi.requestAccess",
            args: [ "{that}.options.sysex", "{that}.events.onAccessGranted.fire", "{that}.events.onAccessError.fire" ]
        },
        refreshPorts: {
            funcName: "flock.midi.system.refreshPorts",
            args: [ "{that}", "{that}.access", "{that}.events.onPortsAvailable.fire" ]
        }
    },
    events: {
        onAccessGranted: null,
        onAccessError: null,
        onReady: null,
        onPortsAvailable: null
    },
    listeners: {
        onCreate: {
            func: "{that}.requestAccess"
        },
        onAccessGranted: [ "flock.midi.system.setAccess({that}, {arguments}.0)", "{that}.refreshPorts()", "{that}.events.onReady.fire({that}.ports)" ],
        onAccessError: {
            funcName: "fluid.log",
            args: [ fluid.logLevel.WARN, "MIDI Access Error: ", "{arguments}.0" ]
        }
    }
}), flock.midi.system.setAccess = function(e, t) {
    e.access = t;
}, flock.midi.system.refreshPorts = function(e, t, n) {
    e.ports = flock.midi.getPorts(t), n(e.ports);
}, fluid.defaults("flock.midi.receiver", {
    gradeNames: [ "fluid.component" ],
    events: {
        raw: null,
        message: null,
        note: null,
        noteOn: null,
        noteOff: null,
        control: null,
        program: null,
        aftertouch: null,
        pitchbend: null,
        sysex: null,
        songPointer: null,
        songSelect: null,
        tuneRequest: null,
        clock: null,
        start: null,
        continue: null,
        stop: null,
        activeSense: null,
        reset: null
    }
}), fluid.defaults("flock.midi.connection", {
    gradeNames: [ "flock.midi.receiver" ],
    openImmediately: !1,
    sysex: !1,
    distributeOptions: {
        source: "{that}.options.sysex",
        target: "{that > system}.options.sysex"
    },
    ports: 0,
    invokers: {
        sendRaw: {
            func: "{that}.events.onSendRaw.fire"
        },
        send: {
            funcName: "flock.midi.connection.send",
            args: [ "{that}", "{arguments}.0" ]
        },
        open: {
            funcName: "flock.midi.connection.bind",
            args: [ "{that}.system.ports", "{that}.options.ports", "{that}.events.onReady.fire", "{that}.events.raw.fire", "{that}.events.onSendRaw" ]
        },
        close: {
            funcName: "flock.midi.connection.close",
            args: [ "{that}.system.ports", "{that}.events.raw.fire" ]
        }
    },
    components: {
        system: {
            type: "flock.midi.system",
            options: {
                events: {
                    onReady: "{connection}.events.onPortsAvailable"
                }
            }
        }
    },
    events: {
        onPortsAvailable: null,
        onReady: null,
        onError: null,
        onSendRaw: null
    },
    listeners: {
        onPortsAvailable: {
            funcName: "flock.midi.connection.autoOpen",
            args: [ "{that}.options.openImmediately", "{that}.open" ]
        },
        onError: {
            funcName: "fluid.log",
            args: [ fluid.logLevel.WARN, "{arguments}.0" ]
        },
        raw: {
            funcName: "flock.midi.connection.fireEvent",
            args: [ "{arguments}.0", "{that}.events" ]
        },
        onDestroy: [ "{that}.close()" ]
    }
}), flock.midi.write = function(e) {
    if ("sysex" === e.type) return flock.midi.write.sysex(e);
    switch (e.type) {
      case "noteOn":
        return flock.midi.write.note(9, e);

      case "noteOff":
        return flock.midi.write.note(8, e);

      case "aftertouch":
        return flock.midi.write.aftertouch(e);

      case "control":
        return flock.midi.write.controlChange(e);

      case "program":
        return flock.midi.write.programChange(e);

      case "pitchbend":
        return flock.midi.write.largeValueMessage(14, e.channel, e);

      case "songPointer":
        return flock.midi.write.largeValueMessage(15, 2, e);

      case "songSelect":
        return flock.midi.write.largeValueMessage(15, 3, e);

      case "tuneRequest":
        return flock.midi.write.singleByteMessage(15, 6);

      case "clock":
        return flock.midi.write.singleByteMessage(15, 8);

      case "start":
        return flock.midi.write.singleByteMessage(15, 10);

      case "continue":
        return flock.midi.write.singleByteMessage(15, 11);

      case "stop":
        return flock.midi.write.singleByteMessage(15, 12);

      case "activeSense":
        return flock.midi.write.singleByteMessage(15, 14);

      case "reset":
        return flock.midi.write.singleByteMessage(15, 15);

      default:
        flock.fail("Cannot write an unrecognized MIDI message of type '" + e.type + "'.");
    }
}, flock.midi.write.note = function(e, t) {
    return flock.midi.write.threeByteMessage(e, t.channel, t.note, t.velocity);
}, flock.midi.write.controlChange = function(e) {
    return flock.midi.write.threeByteMessage(11, e.channel, e.number, e.value);
}, flock.midi.write.programChange = function(e) {
    return flock.midi.write.twoByteMessage(12, e.channel, e.program);
}, flock.midi.write.aftertouch = function(e) {
    return e.note ? flock.midi.write.note(10, e) : flock.midi.write.twoByteMessage(13, e.channel, e.pressure);
}, flock.midi.write.singleByteMessage = function(e, t) {
    var n = new Uint8Array(1);
    return n[0] = flock.midi.write.statusByte(e, t), n;
}, flock.midi.write.twoByteMessage = function(e, t, n) {
    var o = new Uint8Array(2);
    return o[0] = flock.midi.write.statusByte(e, t), o[1] = n, o;
}, flock.midi.write.threeByteMessage = function(e, t, n, o) {
    var r = new Uint8Array(3);
    return r[0] = flock.midi.write.statusByte(e, t), r[1] = n, r[2] = o, r;
}, flock.midi.write.largeValueMessage = function(e, t, n) {
    var o = new Uint8Array(3);
    return o[0] = flock.midi.write.statusByte(e, t), flock.midi.write.twoByteValue(n.value, o, 1), 
    o;
}, flock.midi.write.statusByte = function(e, t) {
    return (e << 4) + t;
}, flock.midi.write.twoByteValue = function(e, t, n) {
    t[n = n || 0] = 127 & e, t[n + 1] = e >> 7 & 127;
}, flock.midi.write.sysex = function(e) {
    240 !== e.data[0] && 247 !== e.data[e.data.length - 1] || flock.fail("Sysex payloads should not include framing bytes.");
    var t = e.data, n = t.length, o = new Uint8Array(n + 2);
    return o[0] = 240, o[n + 1] = 247, o.set(t, 1), o;
}, flock.midi.connection.send = function(e, t) {
    var n = flock.midi.write(t);
    e.events.onSendRaw.fire(n);
}, flock.midi.connection.autoOpen = function(e, t) {
    e && t();
}, flock.midi.findPorts = function(n, e) {
    e = fluid.makeArray(e);
    var o = [];
    return fluid.each(e, function(e) {
        var t = flock.midi.findPorts.portFinder(e)(n);
        o = o.concat(t);
    }), o;
}, flock.midi.findPorts.portFinder = function(e) {
    if ("number" == typeof e) return flock.midi.findPorts.byIndex(e);
    "string" == typeof e && (e = {
        name: e
    });
    var t = e.id ? flock.midi.findPorts.idMatcher(e.id) : e.manufacturer && e.name ? flock.midi.findPorts.bothMatcher(e.manufacturer, e.name) : e.manufacturer ? flock.midi.findPorts.manufacturerMatcher(e.manufacturer) : flock.midi.findPorts.nameMatcher(e.name);
    return function(e) {
        return e.filter(t);
    };
}, flock.midi.findPorts.byIndex = function(n) {
    return function(e) {
        var t = e[n];
        return t ? [ t ] : [];
    };
}, flock.midi.findPorts.lowerCaseContainsMatcher = function(a) {
    return function(e) {
        var t;
        for (var n in a) {
            var o = e[n], r = a[n];
            if (!(t = "*" === r || o && -1 < o.toLowerCase().indexOf(r.toLowerCase()))) break;
        }
        return t;
    };
}, flock.midi.findPorts.idMatcher = function(t) {
    return function(e) {
        return e.id === t;
    };
}, flock.midi.findPorts.bothMatcher = function(e, t) {
    return flock.midi.findPorts.lowerCaseContainsMatcher({
        manufacturer: e,
        name: t
    });
}, flock.midi.findPorts.manufacturerMatcher = function(e) {
    return flock.midi.findPorts.lowerCaseContainsMatcher({
        manufacturer: e
    });
}, flock.midi.findPorts.nameMatcher = function(e) {
    return flock.midi.findPorts.lowerCaseContainsMatcher({
        name: e
    });
}, flock.midi.findPorts.eachPortOfType = function(e, t, n) {
    var o = fluid.makeArray(e);
    fluid.each(o, function(e) {
        e.type === t && n(e);
    });
}, flock.midi.connection.openPort = function(e, t) {
    if (e.open) {
        var n = e.open();
        t.push(n);
    }
    return t;
}, flock.midi.connection.listen = function(e, t, n) {
    return flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
        flock.midi.connection.openPort(e, n), e.addEventListener("midimessage", t, !1);
    }), n;
}, flock.midi.connection.stopListening = function(e, t) {
    flock.midi.findPorts.eachPortOfType(e, "input", function(e) {
        e.close(), e.removeEventListener("midimessage", t, !1);
    });
}, flock.midi.connection.bindSender = function(e, t, n) {
    var o = fluid.makeArray(e);
    return fluid.each(o, function(e) {
        flock.midi.connection.openPort(e, n), t.addListener(e.send.bind(e));
    }), n;
}, flock.midi.connection.fireReady = function(e, t) {
    !e || e.length < 1 || Promise.all(e).then(t);
}, flock.midi.connection.bind = function(e, t, n, o, r) {
    t = flock.midi.connection.expandPortSpec(t);
    var a = flock.midi.findPorts(e.inputs, t.input), i = flock.midi.findPorts(e.outputs, t.output), l = [];
    a && 0 < a.length ? flock.midi.connection.listen(a, o, l) : void 0 !== t.input && flock.midi.connection.logNoMatchedPorts("input", t), 
    i && 0 < i.length ? flock.midi.connection.bindSender(i, r, l) : void 0 !== t.output && flock.midi.connection.logNoMatchedPorts("output", t), 
    flock.midi.connection.fireReady(l, n);
}, flock.midi.connection.close = function(e, t) {
    flock.midi.connection.stopListening(e.inputs, t);
}, flock.midi.connection.logNoMatchedPorts = function(e, t) {
    fluid.log(fluid.logLevel.WARN, "No matching " + e + " ports were found for port specification: ", t[e]);
}, flock.midi.connection.expandPortSpec = function(e) {
    if (void 0 !== e.input || void 0 !== e.output) return e;
    var t = {
        input: {},
        output: {}
    };
    return "number" == typeof e ? t.input = t.output = e : (flock.midi.connection.expandPortSpecProperty("manufacturer", e, t), 
    flock.midi.connection.expandPortSpecProperty("name", e, t)), t;
}, flock.midi.connection.expandPortSpecProperty = function(e, t, n) {
    return n.input[e] = n.output[e] = t[e], n;
}, flock.midi.connection.fireEvent = function(e, t) {
    var n = flock.midi.read(e.data), o = n.type ? t[n.type] : void 0;
    t.message.fire(n, e), "noteOn" !== n.type && "noteOff" !== n.type || t.note.fire(n, e), 
    o && o.fire(n, e);
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.midi.controller", {
    gradeNames: [ "fluid.component" ],
    members: {
        controlMap: {
            expander: {
                funcName: "flock.midi.controller.optimizeMIDIMap",
                args: [ "{that}.options.controlMap" ]
            }
        },
        noteMap: {
            expander: {
                funcName: "flock.midi.controller.optimizeNoteMap",
                args: [ "{that}.options.noteMap" ]
            }
        }
    },
    controlMap: {},
    noteMap: {},
    components: {
        synthContext: {
            type: "flock.band"
        },
        connection: {
            type: "flock.midi.connection",
            options: {
                ports: {
                    input: "*"
                },
                openImmediately: !0
            }
        }
    },
    invokers: {
        mapControl: {
            funcName: "flock.midi.controller.mapControl",
            args: [ "{arguments}.0", "{that}.synthContext", "{that}.controlMap" ]
        },
        mapNote: {
            funcName: "flock.midi.controller.mapNote",
            args: [ "{arguments}.0", "{arguments}.1", "{that}.synthContext", "{that}.noteMap" ]
        }
    },
    events: {
        control: "{that}.connection.events.control",
        note: "{that}.connection.events.note",
        noteOn: "{that}.connection.events.noteOn",
        noteOff: "{that}.connection.events.noteOff"
    },
    listeners: {
        control: "{that}.mapControl({arguments}.0)",
        note: "{that}.mapNote(note, {arguments}.0)",
        noteOn: "{that}.mapNote(noteOn, {arguments}.0)",
        noteOff: "{that}.mapNote(noteOff, {arguments}.0)"
    }
}), flock.midi.controller.optimizeMIDIMap = function(e) {
    var o = new Array(127);
    return fluid.each(e, function(e, t) {
        var n = Number(t);
        o[n] = fluid.makeArray(e);
    }), o;
}, flock.midi.controller.optimizeNoteMap = function(e) {
    return {
        note: fluid.makeArray(e.note),
        noteOn: fluid.makeArray(e.noteOn),
        noteOff: fluid.makeArray(e.noteOff),
        velocity: fluid.makeArray(e.velocity)
    };
}, flock.midi.controller.expandControlMapSpec = function(e, t) {
    return t.transform.id = e, t.valuePath = t.valuePath || "value", t.transform.ugen || (t.transform.ugen = "flock.ugen.value"), 
    t;
}, flock.midi.controller.makeValueSynth = function(e, t, n) {
    var o = (n = flock.midi.controller.expandControlMapSpec(t, n)).transform, r = n.valuePath;
    flock.set(o, r, e);
    var a = flock.synth.value({
        synthDef: o
    });
    return n.valuePath = t + "." + r, a;
}, flock.midi.controller.transformValue = function(e, t) {
    var n = t.transform;
    return "function" == typeof n ? n(e) : (t.transformSynth ? t.transformSynth.set(t.valuePath, e) : t.transformSynth = flock.midi.controller.makeValueSynth(e, "flock-midi-controller-in", t), 
    t.transformSynth.value());
}, flock.midi.controller.setMappedValue = function(e, t, n) {
    e = void 0 !== t.value ? t.value : t.transform ? flock.midi.controller.transformValue(e, t) : e, 
    (n[t.synth] || n).set(t.input, e);
}, flock.midi.controller.mapMIDIValue = function(e, t, n) {
    if (t && !(t.length < 1)) for (var o = 0; o < t.length; o++) {
        var r = t[o];
        flock.midi.controller.setMappedValue(e, r, n);
    }
}, flock.midi.controller.mapControl = function(e, t, n) {
    var o = n[e.number], r = e.value;
    flock.midi.controller.mapMIDIValue(r, o, t);
}, flock.midi.controller.mapNote = function(e, t, n, o) {
    var r = o[e], a = t.note, i = o.velocity, l = t.velocity;
    flock.midi.controller.mapMIDIValue(a, r, n), flock.midi.controller.mapMIDIValue(l, i, n);
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.nativeNodeManager", {
    gradeNames: [ "fluid.component" ],
    members: {
        outputNode: void 0,
        inputNodes: []
    },
    components: {
        scriptProcessor: {
            createOnEvent: "onCreateScriptProcessor",
            type: "flock.webAudio.scriptProcessor",
            options: {
                nodeSpec: {
                    inputs: {
                        0: "{inputMerger}"
                    }
                }
            }
        },
        merger: {
            type: "flock.webAudio.channelMerger"
        }
    },
    invokers: {
        connect: "{that}.events.onConnect.fire",
        disconnect: "{that}.events.onDisconnect.fire",
        createNode: {
            funcName: "flock.webAudio.createNode",
            args: [ "{audioSystem}.context", "{arguments}.0" ]
        },
        createInputNode: {
            funcName: "flock.webAudio.nativeNodeManager.createInputNode",
            args: [ "{that}", "{arguments}.0", "{arguments}.1" ]
        },
        createMediaStreamInput: {
            funcName: "flock.webAudio.nativeNodeManager.createInputNode",
            args: [ "{that}", {
                node: "MediaStreamSource",
                args: [ "{arguments}.0" ]
            }, "{arguments}.1" ]
        },
        createMediaElementInput: {
            funcName: "flock.webAudio.nativeNodeManager.createInputNode",
            args: [ "{that}", {
                node: "MediaElementSource",
                args: [ "{arguments}.0" ]
            }, "{arguments}.1" ]
        },
        createOutputNode: {
            funcName: "flock.webAudio.nativeNodeManager.createOutputNode",
            args: [ "{that}", "{arguments}.0" ]
        },
        insertInput: {
            funcName: "flock.webAudio.nativeNodeManager.insertInput",
            args: [ "{that}", "{audioSystem}.model", "{enviro}", "{arguments}.0", "{arguments}.1" ]
        },
        removeInput: {
            funcName: "flock.webAudio.nativeNodeManager.removeInput",
            args: [ "{arguments}.0", "{that}.inputNodes" ]
        },
        removeAllInputs: {
            funcName: "flock.webAudio.nativeNodeManager.removeAllInputs",
            args: "{that}.inputNodes"
        },
        insertOutput: {
            funcName: "flock.webAudio.nativeNodeManager.insertOutput",
            args: [ "{that}", "{arguments}.0" ]
        },
        removeOutput: {
            funcName: "flock.webAudio.nativeNodeManager.removeOutput",
            args: [ "{scriptProcessor}.node" ]
        }
    },
    events: {
        onStart: "{enviro}.events.onStart",
        onStop: "{enviro}.events.onStop",
        onReset: "{enviro}.events.onReset",
        onCreateScriptProcessor: null,
        onConnect: null,
        onDisconnectNodes: null,
        onDisconnect: null
    },
    listeners: {
        onCreate: [ "{that}.events.onCreateScriptProcessor.fire()", {
            func: "{that}.insertOutput",
            args: "{scriptProcessor}.node"
        } ],
        onStart: [ "{that}.connect()" ],
        onConnect: [ {
            this: "{merger}.node",
            method: "connect",
            args: [ "{scriptProcessor}.node" ]
        }, {
            this: "{that}.outputNode",
            method: "connect",
            args: [ "{audioSystem}.context.destination" ]
        }, {
            funcName: "flock.webAudio.nativeNodeManager.connectOutput",
            args: [ "{scriptProcessor}.node", "{that}.outputNode" ]
        } ],
        onStop: [ "{that}.disconnect()" ],
        onDisconnectNodes: [ {
            this: "{merger}.node",
            method: "disconnect",
            args: [ 0 ]
        }, {
            this: "{scriptProcessor}.node",
            method: "disconnect",
            args: [ 0 ]
        }, {
            this: "{that}.outputNode",
            method: "disconnect",
            args: [ 0 ]
        } ],
        "onDisconnect.onDisconnectNodes": {
            func: "{that}.events.onDisconnectNodes.fire"
        },
        onReset: [ "{that}.removeAllInputs()", "{that}.events.onCreateScriptProcessor.fire()" ],
        onDestroy: [ "{that}.events.onDisconnectNodes.fire()", "{that}.removeAllInputs()", "flock.webAudio.nativeNodeManager.disconnectOutput({that})" ]
    }
}), flock.webAudio.nativeNodeManager.createInputNode = function(e, t, n) {
    var o = e.createNode(t);
    return e.insertInput(o, n);
}, flock.webAudio.nativeNodeManager.createOutputNode = function(e, t) {
    var n = e.createNode(t);
    return e.insertOutput(n);
}, flock.webAudio.nativeNodeManager.connectOutput = function(e, t) {
    e !== t && e.connect(t);
}, flock.webAudio.nativeNodeManager.disconnectOutput = function(e) {
    e.outputNode && e.outputNode.disconnect(0);
}, flock.webAudio.nativeNodeManager.removeAllInputs = function(e) {
    for (var t = 0; t < e.length; t++) e[t].disconnect(0);
    e.length = 0;
}, flock.webAudio.nativeNodeManager.insertInput = function(e, t, n, o, r) {
    var a = t.numInputBuses;
    if (!(e.inputNodes.length >= a)) {
        var i = (r = void 0 === r ? n.busManager.acquireNextBus("input") : r) - t.chans;
        return e.inputNodes.push(o), o.connect(e.merger.node, 0, i), r;
    }
    flock.fail("There are too many input nodes connected to Flocking. The maximum number of input buses is currently set to " + a + ". Either remove an existing input node or increase Flockings numInputBuses option.");
}, flock.webAudio.nativeNodeManager.removeInput = function(e, t) {
    var n = t.indexOf(e);
    -1 < n && t.splice(n, 1), e.disconnect(0);
}, flock.webAudio.nativeNodeManager.insertOutput = function(e, t) {
    return flock.webAudio.nativeNodeManager.disconnectOutput(e), e.outputNode = t;
}, flock.webAudio.nativeNodeManager.removeOutput = function(e) {
    flock.webAudio.nativeNodeManager.insertOutput(e);
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

fluid.defaults("flock.webAudio.outputManager", {
    gradeNames: [ "flock.outputManager" ],
    model: {
        isGenerating: !1,
        shouldInitSafari: flock.platform.browser.safari,
        audioSettings: {}
    },
    invokers: {
        bindAudioProcess: {
            funcName: "flock.webAudio.outputManager.bindAudioProcess",
            args: [ "{enviro}.nodeList", "{busManager}.buses", "{nativeNodeManager}", "{that}.model" ]
        },
        unbindAudioProcess: {
            funcName: "flock.webAudio.outputManager.unbindAudioProcess",
            args: [ "{nativeNodeManager}" ]
        }
    },
    listeners: {
        "{nativeNodeManager}.events.onConnect": [ "{that}.bindAudioProcess()" ],
        "{nativeNodeManager}.events.onDisconnect": [ "{that}.unbindAudioProcess()" ],
        onStart: [ {
            func: "{that}.applier.change",
            args: [ "isGenerating", !0 ]
        }, {
            priority: "last",
            funcName: "flock.webAudio.outputManager.safariStart",
            args: [ "{that}", "{audioSystem}.context", "{nativeNodeManager}.scriptProcessor.node" ]
        } ],
        onStop: [ {
            func: "{that}.applier.change",
            args: [ "isGenerating", !1 ]
        } ],
        "onDestroy.unbindAudioProcess": "{that}.unbindAudioProcess()"
    }
}), flock.webAudio.outputManager.bindAudioProcess = function(e, t, n, o) {
    var r = n.scriptProcessor.node;
    r.model = o, r.nodeList = e, r.buses = t, r.inputNodes = n.inputNodes, r.onaudioprocess = flock.webAudio.outputManager.writeSamples;
}, flock.webAudio.outputManager.unbindAudioProcess = function(e) {
    e.scriptProcessor.node.onaudioprocess = void 0;
}, flock.webAudio.outputManager.writeSamples = function(e) {
    var t, n, o, r = this.inputNodes ? this.inputNodes.length : 0, a = this.nodeList.nodes, i = this.model.audioSettings, l = e.inputBuffer, u = e.outputBuffer, s = i.numBlocks, f = this.buses, c = i.numBuses, d = i.blockSize, m = i.chans, h = l.numberOfChannels;
    if (a.length < 1) for (t = 0; t < m; t++) flock.clearBuffer(u.getChannelData(t)); else for (n = 0; n < s; n++) {
        var p = n * d;
        if (flock.evaluate.clearBuses(f, c, d), 0 < r) for (t = 0; t < h; t++) {
            var k = l.getChannelData(t), g = f[m + t];
            for (o = 0; o < d; o++) g[o] = k[o + p];
        }
        for (flock.evaluate.synths(a), t = 0; t < m; t++) {
            var v = f[t], y = u.getChannelData(t);
            for (o = 0; o < d; o++) y[o + p] = v[o];
        }
    }
}, flock.webAudio.outputManager.safariStart = function(e, t, n) {
    e.model.shouldInitSafari && (t.resume(), e.applier.change("shouldInitSafari", !1));
};

flock = (fluid = fluid || require("infusion")).registerNamespace("flock");

!function() {
    var a = fluid.registerNamespace("jQuery");
    flock.ugenDefaults = function(e, t) {
        return 1 === arguments.length ? flock.ugenDefaults.store[e] : flock.ugenDefaults.store[e] = t;
    }, flock.ugenDefaults.store = {}, flock.isUGen = function(e) {
        return e && e.tags && -1 < e.tags.indexOf("flock.ugen");
    }, flock.aliasUGen = function(e, t, n, o) {
        var r = flock.get(e);
        flock.set(r, t, function(e, t, n) {
            return n = a.extend(!0, {}, o, n), r(e, t, n);
        }), flock.ugenDefaults(e + "." + t, n);
    }, flock.aliasUGens = function(e, t) {
        var n, o;
        for (n in t) o = t[n], flock.aliasUGen(e, n, {
            inputs: o.inputDefaults
        }, o.options);
    }, flock.copyUGenDefinition = function(e, t) {
        var n = flock.ugenDefaults(e), o = fluid.getGlobalValue(e);
        fluid.setGlobalValue(t, o), flock.ugenDefaults(t, fluid.copy(n));
    }, flock.krMul = function(e, t, n) {
        var o, r = n.output[0];
        for (o = 0; o < e; o++) t[o] = t[o] * r;
    }, flock.mul = function(e, t, n) {
        var o, r = n.output;
        for (o = 0; o < e; o++) t[o] = t[o] * r[o];
    }, flock.krAdd = function(e, t, n, o) {
        var r, a = o.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] + a;
    }, flock.add = function(e, t, n, o) {
        var r, a = o.output;
        for (r = 0; r < e; r++) t[r] = t[r] + a[r];
    }, flock.krMulAdd = function(e, t, n, o) {
        var r, a = n.output[0], i = o.output;
        for (r = 0; r < e; r++) t[r] = t[r] * a + i[r];
    }, flock.mulKrAdd = function(e, t, n, o) {
        var r, a = n.output, i = o.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] * a[r] + i;
    }, flock.krMulKrAdd = function(e, t, n, o) {
        var r, a = n.output[0], i = o.output[0];
        for (r = 0; r < e; r++) t[r] = t[r] * a + i;
    }, flock.mulAdd = function(e, t, n, o) {
        var r, a = n.output, i = o.output;
        for (r = 0; r < e; r++) t[r] = t[r] * a[r] + i[r];
    }, flock.onMulAddInputChanged = function(t) {
        var e, n = t.inputs.mul, o = t.inputs.add;
        n || o ? (e = n ? o ? n.rate !== flock.rates.AUDIO ? o.rate !== flock.rates.AUDIO ? flock.krMulKrAdd : flock.krMulAdd : o.rate !== flock.rates.AUDIO ? flock.mulKrAdd : flock.mulAdd : n.rate !== flock.rates.AUDIO ? flock.krMul : flock.mul : o.rate !== flock.rates.AUDIO ? flock.krAdd : flock.add, 
        t.mulAddFn = e, t.mulAdd = function(e) {
            t.mulAddFn(e, t.output, t.inputs.mul, t.inputs.add);
        }) : t.mulAdd = t.mulAddFn = flock.noOp;
    }, flock.ugen = function(e, t, n) {
        var l = {
            enviro: (n = n || {}).enviro || flock.environment,
            rate: n.rate || flock.rates.AUDIO,
            inputs: e,
            output: t,
            options: n,
            model: n.model || {
                unscaledValue: 0,
                value: 0
            },
            multiInputs: {},
            tags: [ "flock.ugen" ]
        };
        return l.lastOutputIdx = l.output.length - 1, l.get = function(e) {
            return flock.input.get(l.inputs, e);
        }, l.set = function(e, t) {
            return flock.input.set(l.inputs, e, t, l, function(e) {
                if (null != e) return flock.parse.ugenDef(e, l.enviro, {
                    audioSettings: l.options.audioSettings,
                    buses: l.buses,
                    buffers: l.buffers
                });
            });
        }, l.input = function(e, t) {
            return e ? "string" == typeof e ? arguments.length < 2 ? l.get(e) : l.set(e, t) : flock.isIterable(e) ? l.get(e) : l.set(e, t) : void 0;
        }, l.calculateStrides = function() {
            var e, t, n, o = l.model, r = l.options.strideInputs, a = l.inputs;
            if (o.strides = o.strides || {}, r) for (e = 0; e < r.length; e++) (n = a[t = r[e]]) ? o.strides[t] = n.rate === flock.rates.AUDIO ? 1 : 0 : fluid.log(fluid.logLevel.WARN, "An invalid input ('" + t + "') was found on a unit generator: " + l);
        }, l.collectMultiInputs = function() {
            var e, t, n, o, r = l.options.multiInputNames, a = l.multiInputs;
            for (e = 0; e < r.length; e++) (n = a[t = r[e]]) ? n.length = 0 : n = a[t] = [], 
            o = l.inputs[t], flock.ugen.collectMultiInputs(o, n);
        }, l.onInputChanged = function(e) {
            var t = l.options.multiInputNames;
            flock.onMulAddInputChanged(l), l.options.strideInputs && l.calculateStrides(), !t || e && !t.indexOf(e) || l.collectMultiInputs();
        }, l.init = function() {
            var e, t, n, o = fluid.makeArray(l.options.tags), r = l.model, a = l.options;
            for (e = 0; e < o.length; e++) l.tags.push(o[e]);
            if (t = a.audioSettings = a.audioSettings || l.enviro.audioSystem.model, r.sampleRate = a.sampleRate || t.rates[l.rate], 
            r.nyquistRate = r.sampleRate, r.blockSize = l.rate === flock.rates.AUDIO ? t.blockSize : 1, 
            r.sampleDur = 1 / r.sampleRate, l.interpolate = flock.interpolate.none, a.interpolation) {
                var i = flock.interpolate[a.interpolation];
                i ? l.interpolate = i : fluid.log(fluid.logLevel.IMPORTANT, "An invalid interpolation type of '" + a.interpolation + "' was specified. Defaulting to none.");
            }
            l.rate === flock.rates.DEMAND && l.inputs.freq && (n = flock.parse.ugenDefForConstantValue(1), 
            l.inputs.freq = flock.parse.ugenDef(n, l.enviro));
        }, l.init(), l;
    }, flock.ugen.collectMultiInputs = function(e, t) {
        flock.isIterable(e) || (e = e = fluid.makeArray(e));
        for (var n = 0; n < e.length; n++) {
            var o = e[n];
            flock.ugen.collectChannelsForInput(o, t);
        }
        return t;
    }, flock.ugen.collectChannelsForInput = function(e, t) {
        var n, o = flock.hasTag(e, "flock.ugen.multiChannelOutput") ? e.output : [ e.output ];
        for (n = 0; n < o.length; n++) t.push({
            rate: e.rate,
            output: o[n]
        });
        return t;
    }, flock.ugen.lastOutputValue = function(e, t) {
        return t[e - 1];
    }, flock.ugen.buffer = function(o) {
        o.onBufferInputChanged = function(e) {
            var t = o.model, n = o.inputs;
            t.bufDef === n.buffer && "buffer" !== e || (t.bufDef = n.buffer, flock.parse.bufferForDef(t.bufDef, o, o.enviro));
        }, o.setBuffer = function(e) {
            o.buffer = e, o.onBufferReady && o.onBufferReady(e);
        }, o.initBuffer = function() {
            o.buffer = o.model.bufDef = flock.bufferDesc({
                format: {
                    sampleRate: o.options.audioSettings.rates.audio
                },
                data: {
                    channels: [ new Float32Array(o.output.length) ]
                }
            });
        };
    }, flock.ugen.value = function(e, t, n) {
        var r = flock.ugen(e, t, n);
        return r.value = function() {
            return r.model.value;
        }, r.dynamicGen = function(e) {
            for (var t = r.output, n = r.model, o = 0; o < e; o++) t[o] = n.unscaledValue;
            r.mulAdd(e), n.value = flock.ugen.lastOutputValue(e, t);
        }, r.onInputChanged = function() {
            var e = r.inputs;
            r.model.unscaledValue = e.value, "constant" !== r.rate ? r.gen = r.dynamicGen : r.gen = void 0, 
            flock.onMulAddInputChanged(r), r.dynamicGen(1);
        }, r.onInputChanged(), r;
    }, flock.ugenDefaults("flock.ugen.value", {
        rate: "control",
        inputs: {
            value: 1,
            mul: null,
            add: null
        },
        ugenOptions: {
            model: {
                unscaledValue: 1,
                value: 1
            },
            tags: [ "flock.ugen.valueType" ]
        }
    }), flock.ugen.silence = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.onInputChanged = function() {
            for (var e = 0; e < o.output.length; e++) o.output[e] = 0;
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.silence", {
        rate: "constant"
    }), flock.ugen.passThrough = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function(e) {
            var t, n, o = i.model, r = i.inputs.source.output, a = i.output;
            for (t = 0; t < r.length; t++) a[t] = n = r[t];
            for (;t < e; t++) a[t] = n = 0;
            o.unscaledValue = n, i.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, a);
        }, i.onInputChanged(), i;
    }, flock.ugenDefaults("flock.ugen.passThrough", {
        rate: "audio",
        inputs: {
            source: null,
            mul: null,
            add: null
        }
    }), flock.ugen.out = function(e, t, n) {
        var k = flock.ugen(e, t, n);
        return k.gen = function(e) {
            var t, n, o, r, a, i, l, u, s, f, c = k.model, d = k.multiInputs.sources, m = k.options.buses, h = k.inputs.bus.output[0], p = k.inputs.expand.output[0];
            if (t = d.length, n = Math.max(p, t), !(t < 1)) {
                for (o = 0; o < n; o++) {
                    for (i = (a = d[o % t]).rate, l = m[h + o], u = i === flock.rates.AUDIO ? 1 : 0, 
                    r = s = 0; r < e; r++, s += u) f = a.output[s], l[r] = l[r] + f;
                    k.mulAddFn(e, l, k.inputs.mul, k.inputs.add);
                }
                c.value = c.unscaledValue = f;
            }
        }, k.init = function() {
            k.sourceBuffers = [], k.onInputChanged();
        }, k.init(), k;
    }, flock.ugenDefaults("flock.ugen.out", {
        rate: "audio",
        inputs: {
            sources: null,
            bus: 0,
            expand: 2
        },
        ugenOptions: {
            tags: [ "flock.ugen.outputType" ],
            multiInputNames: [ "sources" ]
        }
    }), flock.ugen.valueOut = function(e, t, n) {
        var o = flock.ugen(e, t, n);
        return o.arraySourceGen = function() {
            var e, t = o.model, n = o.inputs.sources;
            for (e = 0; e < n.length; e++) t.value[e] = n[e].output[0];
        }, o.ugenSourceGen = function() {
            o.model.value = o.model.unscaledValue = o.inputs.sources.output[0];
        }, o.onInputChanged = function() {
            var e = o.model, t = o.inputs.sources;
            flock.isIterable(t) ? (o.gen = o.arraySourceGen, e.value = new Float32Array(t.length), 
            e.unscaledValue = e.value) : o.gen = o.ugenSourceGen;
        }, o.onInputChanged(), o;
    }, flock.ugenDefaults("flock.ugen.valueOut", {
        rate: "control",
        inputs: {
            sources: null
        },
        ugenOptions: {
            model: {
                unscaledValue: null,
                value: null
            },
            tags: [ "flock.ugen.outputType", "flock.ugen.valueType" ]
        }
    }), flock.ugen.in = function(e, t, n) {
        var u = flock.ugen(e, t, n);
        return u.singleBusGen = function(e) {
            var t = u.model, n = u.output;
            flock.ugen.in.readBus(e, n, u.inputs.bus, u.options.buses), t.unscaledValue = flock.ugen.lastOutputValue(e, n), 
            u.mulAdd(e), t.value = flock.ugen.lastOutputValue(e, n);
        }, u.multiBusGen = function(e) {
            var t, n, o, r = u.model, a = u.inputs.bus, i = u.options.buses, l = u.output;
            for (t = 0; t < e; t++) {
                for (n = o = 0; n < a.length; n++) o += i[0 | a[n].output[0]][t];
                l[t] = o;
            }
            r.unscaledValue = o, u.mulAdd(e), r.value = flock.ugen.lastOutputValue(e, l);
        }, u.onInputChanged = function() {
            u.gen = flock.isIterable(u.inputs.bus) ? u.multiBusGen : u.singleBusGen, flock.onMulAddInputChanged(u);
        }, u.onInputChanged(), u;
    }, flock.ugen.in.readBus = function(e, t, n, o) {
        var r, a = o[0 | n.output[0]];
        for (r = 0; r < e; r++) t[r] = a[r];
    }, flock.ugenDefaults("flock.ugen.in", {
        rate: "audio",
        inputs: {
            bus: 0,
            mul: null,
            add: null
        }
    }), flock.ugen.audioIn = function(e, t, n) {
        var i = flock.ugen(e, t, n);
        return i.gen = function(e) {
            var t, n, o = i.model, r = i.output, a = i.bus;
            for (t = 0; t < e; t++) r[t] = n = a[t];
            o.unscaledValue = n, i.mulAdd(e), o.value = flock.ugen.lastOutputValue(e, r);
        }, i.onInputChanged = function() {
            flock.onMulAddInputChanged(i);
        }, i.init = function() {
            var e = i.enviro.audioSystem.inputDeviceManager.openAudioDevice(n);
            i.bus = i.options.buses[e], i.onInputChanged();
        }, i.init(), i;
    }, flock.ugenDefaults("flock.ugen.audioIn", {
        rate: "audio",
        inputs: {
            mul: null,
            add: null
        }
    });
}();